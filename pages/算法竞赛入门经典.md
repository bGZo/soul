alias:: books/算法竞赛入门经典
tags:: algo
author:: 刘汝佳
publisher:: 清华大学出版社
published-date:: 20091100
source:: https://book.douban.com/subject/4138920

- 程序设计入门
  collapsed:: true
  - 算术表达式
  - 变量及其输入
  - 顺序结构程序设计
  - 分支结构程序设计
  - 小结与习题
    collapsed:: true
    - 数据类型实验
    - scanf输入格式实验
    - printf语句输出实验
    - 测测你的实践能力
    - 小结
    - 上机练习
  - #+BEGIN_TIP
    scanf中的占位符和变量的数据类型应一一对应，且每个变量前需要＆符号
    #+END_TIP
  - #+BEGIN_TIP
    在学习编程时，“明知故犯”是有益的：起码你知道了错误时的现象。这样，当你真的不小心犯错时，可以通过现象猜测到
    #+END_TIP
  - #+BEGIN_TIP
    在一般情况下，你的程序不能直接读取键盘和控制屏幕：不要在算法竞赛中便用getch()、getche()、gotoxy()、clrscr()（早期的教材中可能会介绍这些函数）
    #+END_TIP
  - #+BEGIN_TIP
    在算法竞赛中，每行输出均应以回车符结束，包括最后一行。除非特别说明，每行的行首不应有空格，但行末通常可以有多余空格。另外，输出的每两个数或者字符串之间应以单个空格隔开
    #+END_TIP
  - #+BEGIN_TIP
    有的读者可能会用math.h中定义的常量M＿PI，但其实**这个常数不是ANSIC标准**的。不信的话用 gcc—ansi 编译试试
    #+END_TIP
  - #+BEGIN_TIP
    尽量用const关键字声明常数
    #+END_TIP
  - #+BEGIN_TIP
    **算法竞赛是在比谁能更好地解决问题，而不是在比谁写的程序看上去更高级**
    多数算法竞赛采用黑盒测试，即只考查程序解决问题的能力，而不关心它采用的什么方法; 换句话说，我们的目标是解决问题，而不是为了写程序而写程序，同时应保持简单（KeepIt Simple and Stupid，KISS），而不是自己创造条件去展示编程技巧
    #+END_TIP
  - #+BEGIN_TIP
    细心的读者也许发现了，如果a为真，则无论b的值如何，allb均为真。换句话说，一旦发现a为真，就不必计算b的值。C语言正是采取了这样的策略，称为短路（short—circuit）。也许你会觉得，用短路的方法计算逻辑表达式的唯一优点是速度更快，但其实并不是这样
    #+END_TIP
  - #+BEGIN_TIP
    重视实验。哪怕不理解背后的道理，至少要清楚现象
    #+END_TIP
  - #+BEGIN_TIP
    学会模仿。本章始终没有介绍 `#include<stdio.h>` 语句的作用，但这丝毫不影响读者编写简单的程序。这看似是在鼓励读者“不求甚解”，但实为考虑到学习规律而作出的决策：初学者自学和理解能力不够，自信心也不够，不适合在动手之前被灌输大量的理论
    正确的处理方法是 "**抓住主要矛盾**" ———— 始终把学习、实验的焦点集中在最有趣的部分。如果直观的解决方案行得通，就不必追究其背后的机理。如果对一个东西不理解，就不要对其进行修改；如果非改不可，则应根据自己的直觉和猜测尝试各种改法，而不必过多地思考“为什么要这样”
    #+END_TIP
  - 交换变量
    - ```c
      // 1
      t = a;
      a = b;
      b = t;
      // 2
      a = a + b;
      b = a - b;
      a = a - b;
      ```
- 循环结构程序设计
  collapsed:: true
  - for循环
  - 循环结构程序设计
  - 文件操作
  - 小结与习题
    collapsed:: true
    - 输出技巧
    - 浮点数陷阱
    - 64位整数
    - C++中的输入输出
    - 小结
    - 上机练习
  - #+BEGIN_TIP
    数组引申出来的打表是很快的，也是一种解决问题的好方法
    #+END_TIP
  - 高精度运算 -- 为什么要逆序表示呢？
    - 因为如果按照从高到低的顺序储存，一旦进位的话就...
  - #+BEGIN_TIP
    有的读者可能会尝试用函数strrev来完成字符串的反转操作，但请注意，strrev函数不是ANSIC的（请用—ansi编译试试看）。
    #+END_TIP
- 数组和字符串
  collapsed:: true
  - 数组
  - 字符数组
  - 最长回文子串
  - 小结与习题
    collapsed:: true
    - 必要的存储量
    - 用ASCII编码表示字符
    - 补码表示法
    - 重新实现库函数
    - 字符串处理的常见问题
    - 关于输入输出
    - I/O的效率
    - 小结
    - 上机练习
- 函数和递归
  collapsed:: true
  - 数学函数
    collapsed:: true
    - 简单函数的编写
    - 使用结构体的函数
    - 应用举例
  - 地址和指针
    collapsed:: true
    - 变量交换
    - 调用栈
    - 用指针实现变量交换
    - 初学者易犯的错误
  - 递归
    collapsed:: true
    - 递归定义
    - 递归函数
    - C语言对递归的支持
    - 段错误与栈溢出
  - 本章小结
    collapsed:: true
    - 小问题集锦
    - 小结
      第2部分 算法篇
- 基础题目选解
  collapsed:: true
  - 字符串
    collapsed:: true
    - WERTYU
    - TeX括号
    - 周期串
  - 高精度运算
    collapsed:: true
    - 小学生算术
    - 阶乘的精确值
    - 高精度运算类bign
    - 重载bign的常用运算符
  - 排序与检索
    collapsed:: true
    - 6174问题
    - 字母重排
  - 数学基础
    collapsed:: true
    - Cantor的数表
    - 因子和阶乘
    - 果园里的树
    - 多少块土地
  - 训练参考
    collapsed:: true
    - 黑盒测试
    - 在线评测系统
    - 推荐题目
- Above: 语言基础; Following: 正片开始
  background-color:: pink
- 数据结构基础
  collapsed:: true
  - 栈和队列
    collapsed:: true
    - 卡片游戏
    - 铁轨
  - 链表
    collapsed:: true
    - 初步分析
    - 链式结构
    - 对比测试
    - 随机数发生器
  - 二叉树
    collapsed:: true
    - 小球下落
    - 层次遍历
    - 二叉树重建
  - 图
    collapsed:: true
    - 黑白图像
    - 走迷宫
    - 拓扑排序
    - 欧拉回路
  - 训练参考
- 暴力求解法
  collapsed:: true
  - 简单枚举
    collapsed:: true
    - 除法
    - 最大乘积
    - 分数拆分
    - 双基回文数
  - 枚举排列
    collapsed:: true
    - 生成1～n的排列
    - 生成可重集的排列
    - 解答树
    - 下一个排列
  - 子集生成
    collapsed:: true
    - 增量构造法
    - 位向量法
    - 二进制法
  - 回溯法
    collapsed:: true
    - 八皇后问题
    - 素数环
    - 困难的串
    - 带宽
  - 隐式图搜索
    collapsed:: true
    - 隐式树的遍历
    - 一般隐式图的遍历
    - 八数码问题
    - 结点查找表
  - 训练参考
- 高效算法设计
  collapsed:: true
  - 算法分析初步
    collapsed:: true
    - 渐进时间复杂度
    - 上界分析
    - 分治法
    - 正确对待算法分析结果
  - 再谈排序与检索
    collapsed:: true
    - 归并排序
    - 快速排序
    - 二分查找
  - 递归与分治
    collapsed:: true
    - 棋盘覆盖问题
    - 循环日程表问题
    - 巨人与鬼
    - 非线性方程求根
    - 最大值最小化
  - 贪心法
    collapsed:: true
    - 最优装载问题
    - 部分背包问题
    - 乘船问题
    - 选择不相交区间
    - 区间选点问题
    - 区间覆盖问题
    - Huffman编码
  - 训练参考
    第3部分 竞赛篇
- 动态规划初步
  collapsed:: true
  - 数字三角形
    collapsed:: true
    - 问题描述与状态定义
    - 记忆化搜索与递推
  - DAG上的动态规划
    collapsed:: true
    - DAG模型
    - 最长路及其字典序
    - 固定终点的最长路和最短路
  - 0-1背包问题
    collapsed:: true
    - 多阶段决策问题
    - 规划方向
    - 滚动数组
  - 递归结构中的动态规划
    collapsed:: true
    - 表达式上的动态规划
    - 凸多边形上的动态规划
    - 树上的动态规划
  - 集合上的动态规划
    collapsed:: true
    - 状态及其转移
    - 隐含的阶段
  - 训练参考
- 数学概念与方法
  collapsed:: true
  - 数论初步
    collapsed:: true
    - 除法表达式
    - 无平方因子的数
    - 直线上的点
    - 同余与模算术
  - 排列与组合
    collapsed:: true
    - 杨辉三角与二项式定理
    - 数论中的计数问题
    - 编码与解码
    - 离散概率初步
  - 递推关系
    collapsed:: true
    - 汉诺塔
    - Fibonacci数列
    - Catalan数
    - 危险的组合
    - 统计n-k特殊集的数目
  - 训练参考
- 图论模型与算法
  collapsed:: true
  - 再谈树
    collapsed:: true
    - 无根树转有根树
    - 表达式树
    - 最小生成树
    - 并查集
  - 最短路问题
    collapsed:: true
    - Dijkstra算法
    - 稀疏图的邻接表
    - 使用优先队列的Dijkstra算法
    - Bellman-Ford算法
    - Floyd算法
  - 网络流初步
    collapsed:: true
    - 最大流问题
    - 增广路算法
    - 最小割最大流定理
    - 最小费用最大流问题
  - 进一步学习的参考
    collapsed:: true
    - 编程语言
    - 数据结构
    - 算法设计
    - 数学
    - 参赛指南
  - 训练参考
- 开发环境与方法
  collapsed:: true
  - 命令行
    collapsed:: true
    - 文件系统
    - 进程
    - 程序的执行
    - 重定向和管道
    - 常见命令
  - 操作系统脚本编程入门
    collapsed:: true
    - Windows下的批处理
    - Linux下的Bash脚本
    - 再谈随机数
  - 编译器和调试器
    collapsed:: true
    - gcc的安装和测试
    - 常见编译选项
    - gdb简介
    - gdb的高级功能
  - 浅谈IDE