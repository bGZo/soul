tags:: #database

- #+BEGIN_WARNING
  **闭包 / 最小依赖集 / 范式优化**
  #+END_WARNING
  via: [数据库必考习题合集_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1P5411e7rU)
  - {{video https://www.bilibili.com/video/BV1P5411e7rU}}
- ## 绪论
  - ### Data #vs DB #vs DBMS #vs DBS
    - 数据 (Data)
      - 描述事物的符号记录，是数据库中的基本对象
    - 数据库 (Database)
      - 是长期储存在计算机内、有组织的、可共享的大量数据的集合 数据库
    - 数据库管理系统 (DBMS, Database Management System)
      - 是位于用户与操作系统之间的一层数据管理软件
      - 主要功能
        - 数据定义功能
        - 数据组织、存储和管理
        - 数据操纵功能(4)
          - 数据的安全性保护
          - 数据的完整性检查
          - 并发控制
          - 数据库恢复
        - 数据库的事务管理和运行管理
        - 数据库的建立和维护
        - 其他功能
    - 数据库系统 (DBS)
      - 由数据库、数据库管理系统 (及其开发工具) 、应用系统、数据库管理员构成的存储、管理、处理和维护数据的系统.
  - ### 数据管理阶段
    collapsed:: true
    - 人工管理阶段
      - 特点
        - 数据不保存
        - 应用程序管理数据
        - 数据不共享
        - 数据不具有独立性
    - 文件系统阶段
      - 特点
        - 数据可长期保存
        - 由文件系统管理数据文件
      - 缺点
        - 数据共享性差，冗余度大
        - 数据独立性差
    - 数据库系统
      - 特点
        - 数据结构化 (与文件系统的本质区别)
        - 数据的共享性高，冗余度低，易扩充
        - 数据独立性高
        - 数据由DBMS统一管理和控制
  - ### 独立性 -> **数据的独立性**
    - 物理独立性
      - 指用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的.
    - 逻辑独立性
      - 指用户的应用程序与数据库的逻辑结构是相互独立的，即数据的逻辑结构改变了，用户程序也可以不变
  - ### 数据模型是数据库系统的核心和基础
    - 数据模型的组成要素:
      - 数据结构: 描述数据库的组成对象以及对象之间的联系
      - 数据操作: 指对数据库中各种对象的实例允许执行的操作集合.
  - ### 数据库系统 (DBS) 的**三级模式结构**
    - 指数据库系统是由==外模式、模式和内模式==三级构成
      - ![image.png](../assets/database/image_1663335773111_0.png){:height 232, :width 355}
    - 模式 (逻辑模式)
      - 是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图. 它是数据库系统模式结构的中间层，既不涉及数据的物理存储细节和硬件环境，也与具体的应用程序、所使用的开发工具及高级程序设计语言无关. 一个数据库只有一个模式
    - 外模式 (子模式、用户模式)
      - 是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示. 通常是模式的子集，一个数据库可以有多个外模式. 外模式是保证数据库安全性的一个有力措施
    - 内模式 (存储模式)
      - 一个数据库只能有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式
      - 外模式/模式映射、模式/内模式映射保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性
  -
- ## 关系数据库
  - ### 概念
    - 数据的完整性约束条件
      - 是指给定的数据模型中数据及其联系所具有的制约和依存规则
    - 实体
      - 客观存在并可相互区别的事物
    - 属性
      - 实体所具有的某一特性
    - 码
      - 唯一标识实体的属性集
    - 域
      - 属性的取值范围
    - 实体型
      - 具有相同属性的实体必然具有的特征和性质. 用实体名及其属性名集合来抽象和刻画同类实体，成为实体型
    - 实体集
      - 同一类型实体的集合
    - 联系
      - 实体内部的联系通常是指组成实体的各属性之间的联系；实体之间的联系通常是指不同实体集之间的联系. 分为三种
      - 分类
        - 一对一联系
        - 一对多联系
        - 多对多联系
    - 关系模型
      - 关系数据模型的数据结构
      - 操纵和完整性约束
      - 存储结构
    - 关系
      - 一个关系对应通常说的一张表
    - 元组
      - 表中的一行即为一个元组
    - 属性
      - 表中的一列即为一个属性
    - 码 (码键)
      - 表中的某个属性组，它可以唯一确定一个元组
    - 域
      - 属性的取值范围
    - 分量
      - 元组中的一个属性值
    - 候选码
      - 若关系中的某一属性组的值能唯一的标识一个元组
    - 主码
      - 若一个关系中有多个候选码，则选定其中一个为主码
    - 主属性
      - 候选码的诸属性. 不包含在任何候选码中的属性称为**非主属性或非码属性**
  - 关系的三种类型
    - 基本关系 (又称基本表、基表)
    - 查询表
    - 视图表
  - 关系模型基本操作
    - 查询操作
    - 插入、删除、修改操作
  - 查询操作分为
    - 选择
    - 投影
    - 连接
    - 除
    - 并
    - 差
    - 交
    - 笛卡尔积 (5种基本操作)
  - 关系操作特点: 集合操作方式，即操作的对象和结果都是集合，也称一次一集合的方式. 非关系数据模型则是一次一记录的方式
  - 关系数据语言分类
    - 关系代数语言
      - 集合运算符
        - 并(union)
        - 差(except)
        - 交(intersection)
        - 笛卡尔积(cartesian product)
      - 关系运算符
        - **选择(select)**:
          - $σ_{SAL>1000}(EMP)$: 取出查询工资大于1000的所有员工的信息
        - **投影(projection)**: $∏_{字段序列}(关系)$
          - $∏_{ENAME,SAL}(EMP)$: 查看所有员工的姓名和工资
        - **连接(join)**
          - $∏_{ENAME,SAL}(σ_{SAL>1000}(EMP))$: 求出了所有工资大于1000的员工的名字和工资, 将 $σ_{SAL>1000}(EMP)$ 执行的结果当做一个临时的关系，参与了投影运算得到
            - **自然连接(natural join)**
              - 所有老师的名字以及其所授课程的id:
                $∏_{name, course_id}(instructor ⋈ teaches)$
        - **除法(division)**
          - 原理解析见[CSDN博客](https://blog.csdn.net/qq_22627687/article/details/53789362)
    - 关系演算语言 (略)
    - 具有关系代数和关系演算
- ## 双重特点的语言 ([[sql]]): 用于和DBMS通信的语言
  - **等值连接** #vs **自然连接**
    - 等值连接
      id:: 6324a046-e91c-4834-b16b-99aeff00c4ea
      - 连接运算符是 "="
      - 从关系R和S的广义笛卡尔积中选取A、B属性值相等的那些元组
    - 自然连接
      - 一种特殊的 ((6324a046-e91c-4834-b16b-99aeff00c4ea))
        - 他要求两个关系中进行比较的分量必须是相同的属性组，并在结果中对重复属性列去重
  - SQL
    - 集 数据查询, 数据定义, 数据操纵 和 数据控制 功能于一体
    - 主要特征包括
      - 综合统一
      - 高度非过程化
      - 面向集合的操作方式
      - 以同一种语法结构提供多种使用方式
      - 语言简洁，易学易用
- ## 数据库的安全性
  - 试述实现数据库安全性控制的常用方法和技术:
    - 用户标识和鉴别
      - 该方法由系统提供一定的方式让用户标识自己的名字或身份. 每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供系统的使用权
    - 存取控制
      - 通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未被授权的人员无法存取数
    - 视图机制
      - 为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护
    - 审计
      - 建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中，DBA 可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等
    - 数据加密
      - 对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容.
  - TCSEC/TDI 从 安全策略、责任、保证和文档 来描述安全性级别划分的标准.
  - GRANT 语句向用户授予权限，REVOKE 语句收回授予的权限
  - 自主存取控制方法: 定义各个用户对不同数据对象的存取权限. 当用户对数据库访问时首先检查用户的存取权限. 防止不合法用户对数据库的存取.
  - 强制存取控制方法: 每一个数据对象被 (强制地) 标以一定的密级，每一个用户也被 (强制地) 授予某一个级别的许可证. 系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象.
- ## 数据库完整性
  - 概念：数据的**正确定和相容性**
  - 数据库的完整性和安全性的区别和联系
    - 数据库的完整性是为了防止数据库存在不符合语义的数据，也就是防止数据库中存在不正确的数据. 完整性检查和控制的防范对象是不合语义的、不正确的数据，防止它们进入数据库.
    - 数据的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏. 安全性控制的防范对象是非法用户和非法操作，防止他们对数据库数据的非法存取.
  - 为维护数据库的完整性，DBMS必须能够
    - 提供定义完整性约束条件的机制
    - 提供完整性检查的方法
    - 违约处理
  - **关系的完整性约束条件**包括
    - **实体完整性**
      id:: 6324a046-261b-4450-a31a-f3834405d506
      - 若属性 (指一个或一组属性) A是基本关系R的主属性，则A不能取空值
    - **参照完整性**
      id:: 6324a046-7e2a-479e-8727-8effabb0d8f4
      - 若属性 (或属性组) F是基本关系R的外码，它与基本关系S的主码Ks相对应 (基本关系R和S不一定是不同的关系) ，则对于R中每个元组在F上的值必须为
        - 或者取空值 (F的每个属性值均为空值)
        - 或者等于S中某个元组的主码值
    - **用户定义的完整性**
  - 关系的两个不变性
    - ((6324a046-261b-4450-a31a-f3834405d506)) 和 ((6324a046-7e2a-479e-8727-8effabb0d8f4)) 的关系模型必须满足的完整性约束条件
- ## 关系数据理论
  - ### 关系模式存在的问题
    - 数据容易太大
    - 更新异常
    - 插入异常
    - 删除异常
  - ### 概念
    - **函数依赖 (functional dependency)**
      - 在一张表中，在属性(或属性组) $X$ 的值确定的情况下，必定能确定属性 $Y$ 的值，那么就可以说 $Y$ 函数依赖于 $X$，写作 $X → Y$
        - 设R(U)是属性集U上的关系模式. X,Y是U的自己. 若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不相等，则称X函数确定Y或Y函数依赖于X，记作X→Y
    - **部分函数依赖 (partial functional dependency)**
      - 如果 $X→Y$，并且存在 $X$ 的一个真子集 $X_0$，使得 $X_0→Y$，则称 $Y$ 对 $X$ 部分函数依赖
      - 比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖与（学号，身份证号）；
    - **完全函数依赖 (full functional dependency)**
      - 在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖
      - 比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；
    - **传递函数依赖 (transitive functional dependency)**
      - 在关系模式 $R(U)$ 中，设 $X$，$Y$，$Z$ 是 $U$ 的不同的属性子集，如果 $X$ 确定 $Y$、$Y$ 确定 $Z$，且有 $X$ 不包含 $Y$，$Y$ 不确定 $X$，$(X∪Y)∩Z=空集合$，则称 $Z$ 传递函数依赖 于 $X$
      - 传递函数依赖会导致数据冗余和异常
      - 传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中
        - 比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖
  - ### \* 规范化
    - 概念：一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫做规范化
    - $1NF$
      - 所有关系型数据库的最基本要求
        - 关系型数据库中创建的表一定满足第一范式
      - 每一个 分量/属性(对应于表中的字段) 必须是不可分的数据项, 也就是这个字段只能是一个值, 不能再分为多个其他的字段了, 满足了这个最低要求的关系模式就属于1NF
    - $2NF$
      - 若 $R∈1NF$，且每一个非主属性完全函数依赖于码，则 $R∈2NF$
      - **消除了非主属性对于码的部分函数依赖**
        - ![image.png](../assets/database/image_1663347983840_0.png)
        - 第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键
    - $3NF$
      - 关系模式 $R\left<U,F\right>$ 中若不存在这样的码 $X$，属性组 $Y$ 及非主属性 $Z$ ($Z$ 不是 $Y$ 的真子集) 使得 $X→Y$，$Y→Z$成立，$Y→Z$，则称 $R\left<U,F\right>∈3NF$
      - **消除了非主属性对于码的传递函数依赖**
        - 符合 3NF 要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题
        - 比如
          - 在关系 $R(学号 , 姓名, 系名，系主任)$ 中
            $学号 → 系名$，$系名 → 系主任$
            所以存在 非主属性系主任 对于 学号 的传递函数依赖
            所以该表的设计，不符合 3NF 的要求
    - $BCNF$
      - 关系模式 $R\left<U,F\right>∈1NF$.若 $X→Y$ 且 $Y$ 不是 $X$ 真子集时 $X$ 必含有码，则 $R\left<U,F\right> ∈ BCNF$
      - 一个关系模式 $R$ 不属于 $2NF$，就会产生以下问题
        - 插入异常
        - 删除异常
        - 修改异常
      - 模式分解的3个定义
        - 分解有 “无损连接性”
        - 分解要 “保持函数依赖”
        - 分解既要 “保持函数依赖”，又要具有“无损连接性”
    - ......
- ## 数据库设计
  id:: 6327cf39-7aed-4f49-a6d3-de8485210ffb
  - ### 数据库设计
    - 概念：对于一个给定的应用环境，构造 (设计) 优化的数据库逻辑模式和物理结构，并据此建立数据库及应用系统，使之能够有效的存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求"
    - 信息管理要求: 在数据库中应该存储和管理哪些数据对象
    - 数据操作要求: 对数据对象e需要进行哪些操作，如查询、增、删、改、统计等操作数据库设计目标，为用户和各应用系统提供一个信息基础设施和高效率的运行环境
      - 高效率的运行环境包括: 数据库数据的存取效率、数据库存储空间的利用率、数据库系统运行管理的效率等都是高的
  - ### 数据可设计的特点(2)
    - 数据库设计的基本规律: “三分技术，七分管理，十二分基础数据”
    - 结构 (数据) 设计和行为 (处理) 设计相结合
  - ### 概念结构的主要特点
    - 能真实、充分地反映现实世界，包括事物和事物之间的联系，能满足用户对数据的粗粒要求，是实现世界的一个真实模型
    - 易于理解，从而可以用它和不熟悉计算机的用户交换意见，用户积极的参与是数据库设计成功的关键
    - 易于更改，当应用环境和应用要求改变时，容易对概念模型修改和扩充
    - 易于向关系、网状、层次等各种数据模型转换
  - ### E-R 图
    id:: 6324a97f-40b0-41e7-812c-db9fc71d5a9a
    - 概念: Entity Relationship Diagram. 实体-联系图. 提供了表示**实体类型、属性和联系的方法**. 用来描述现实世界的概念模型. 用来捋清数据库设计
    - 它是描述现实世界关系**概念模型**的有效方法
    - Case: 学生选课
      - ![image.png](../assets/image_1663347347280_0.png)
      - ER 图转换成数据库实际的关系模型
        ![image.png](../assets/image_1663347369828_0.png)
  - More Via [[mysql-index]]
- ## 查询处理与查询优化
  - 查询优化的优点不仅在于用户不必考虑如何最好的表达查询以获得较好的效率，而且在于系统可以比用户程序的“优化”做得更好
  - 查询优化的总目标: 选择有效的策略，求得给定关系表达式的值，使得查询代价最小
  - 代数优化策略是通过对关系代数表达式的等价变化来提高查询效率 物理优化就是
  - 要选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标
- ## 数据库恢复技术  #transaction
  - ### 事务
    - 概念：用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是不可分割的工作单位"
    - 通常以 `BEGIN TRANSACTION` 开始，以 `COMMIT/ROLLBACK` 结束.
      - `COMMIT` 表示提交，提交事务的所有操作
      - `ROLLBACK` 表示回滚，即在事务运行过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态
    - {{embed ((6324a046-49b3-48d6-8275-b6b0feca5d51))}}
  - ### **故障的种类及恢复策略**
    - 事务故障
      collapsed:: true
      - 反向扫描文件日志，查找该事务的更新操作
      - 对该事务的更新操作执行逆操作
      - 继续反向扫描日志文件，做同样处理
      - 如此处理下去，直至读到此事务的开始标记，该事务故障的恢复就完成了
    - 系统故障 (软故障)
      collapsed:: true
      - 正向扫描日志文件，找出在故障发生前已经提交的事务队列和未完成的事务队列
      - 对撤销队列中的各个事务进行撤销处理
      - 对重做队列中的各个事务进行重做处理
    - 介质故障 (硬) : 最严重的一种故障. 恢复方法是重装数据库，然后重做已完成的事务.
      collapsed:: true
      - 装入最新的数据库后备副本 (离故障发生时刻最近的转储副本) , 使数据库恢复到转储时的一致性状态
      - 装入转储结束时刻的日志文件副本，重做已完成的事务.
    - 计算机病毒
  - ### 数据库恢复的基本技术 -> 恢复到故障前某个一致性状态
    - 建立冗余数据最常用的技术
      - **数据转储**
      - **登记日志文件**
    - 检查点记录是一类新的日志记录.
      - 建立检查点时刻所有正在执行的事务清单
      - 这些事务的最近一个日志记录的地址
  - ### \* ==**事务隔离级别**==
    id:: 6327cf39-8e1a-4229-8d14-6dd05b40c394
    - https://en.wikipedia.org/wiki/Isolation_(database_systems)
    - 概念：**定义了数据库系统中一个事务中操作的结果在何时以何种方式对其他并发事务操作可见**
    - 读取未提交 (**READ-UNCOMMITTED**)
      id:: 63324885-8488-404a-a5eb-9da6a8bc2e1e
      - 最低的隔离级别
      - 允许读取尚未提交的数据变更
      - 可能会导致脏读、幻读或不可重复读
    - 读取已提交 (**READ-COMMITTED**)
      id:: 4f64c574-e0a7-4184-89f4-fbcb4d10e068
      - 允许读取并发事务已经提交的数据
      - 可以阻止脏读，但是幻读或不可重复读仍有可能发生
    - 可重复读 (**REPEATABLE-READ**)
      id:: 326b3175-01ba-496e-abf3-7586c8808be5
      - 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改
      - 可以阻止脏读和不可重复读，但幻读仍有可能发生
    - 可串行化 (**SERIALIZABLE**)
      id:: 31c65180-919f-4848-b9ca-bfc9b6aa04fc
      - 最高的隔离级别, 完全服从 ACID 的隔离级别
      - 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰
        - 该级别可以防止脏读、不可重复读以及幻读
    - | 隔离级别 | ((6327cf39-9a0a-46f2-81f6-e21316b5cd87)) | ((6324a8c0-48a2-4372-a89a-4158648775fa)) | ((6324b41d-7420-4caa-8173-60413813076d)) |
      | ---- | ---- | ---- |
      | ((63324885-8488-404a-a5eb-9da6a8bc2e1e)) | √ | √ | √ |
      | ((4f64c574-e0a7-4184-89f4-fbcb4d10e068)) | × | √ | √ |
      | ((326b3175-01ba-496e-abf3-7586c8808be5)) | × | × | √ |
      | ((31c65180-919f-4848-b9ca-bfc9b6aa04fc)) | × | × | × |
  - ### 并发 带来的数据的不一致问题
    - 脏读 (Dirty read)
      id:: 6327cf39-9a0a-46f2-81f6-e21316b5cd87
    - 丢失修改 (Lost to modify)
    - 不可重复读 (Unrepeatable read)
      id:: 6324a8c0-48a2-4372-a89a-4158648775fa
      - 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样
    - 幻读 (Phantom read)
      id:: 6324b41d-7420-4caa-8173-60413813076d
      - 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样
    - ---
    - ((6324a8c0-48a2-4372-a89a-4158648775fa)) #vs ((6324b41d-7420-4caa-8173-60413813076d))
      - 幻读是不可重复读的一种特殊情况
        - 不可重复读的重点是**内容修改或者记录减少**
        - 幻读在于**记录新增**
  - ### 避免死锁的简单方法是采用先来先服务的策略
  - ### 三级封锁协议
    - 一级封锁协议
      - 写数据前加写锁，读数据不加锁. 只能防止丢失修改.
    - 二级封锁协议
      - 在一级封锁协议上，读取数据需要加读锁，读完就释放. 避免读脏数据.
    - 三级封锁协议
      - 一级封锁协议上，读数据加读锁，事务结束再释放.
- ## [[PostgreSQL]] 源码分析
  - > 查看开源数据库 PostgreSQL 源码，并分析其查询处理的具体实现过程（包括涉及到的函数（或 API），以及函数之间的关系等）。
    - psql的源码分为两部分，一部分是psql的前台处理代码，代码都放在/src/bin/psql下；另一部分就是后台的查询处理过程的代码，代码较多，过程也较为复杂。这部分代码分布在/src/backend/目录下的许多子目录中
    - A Tour of PostgreSQL Internals
    - 查询处理
    - postgresql log: https://www.postgresql.org/docs/13/release-13-2.html
      postgresql document: https://www.postgresql.org/files/documentation/pdf/13/postgresql-13-A4.pdf
        --> queries 111-138
        --> parallel
            --> How Parallel Query Works
    - reference:
      - [用户中心 - 博客园](https://home.cnblogs.com/u/flying-tiger/)
      - [数据库内核月报](http://mysql.taobao.org/monthly/2021/01/)
      - [数据库内核月报](http://mysql.taobao.org/monthly/2020/08/07/)
      - [Nginx开发从入门到精通 — Nginx开发从入门到精通](http://tengine.taobao.org/book/)
  - 如果我可以预先知道后面的章节，所有工作都会比现在更好. 在读源码的过程中, VSCode的扩展 `Comment Translate` 帮助了我很多. PostgreSQL的源码很棒，所有模型都充满了注释. PostgreSQL 总流程和 Oracle 是相同的, 所以这里之说说差异细节.
  - 正如我们知道的，流程就像 `Parser -(tree)> Rewriter -(convert)> Planner -(review)> Executor(do)`. 首先，解析器在 `./src/backend/parser/scan.l` 路径下使用 [flex](http://www.cs.virginia.edu/~cr4bd/flex-manual), 在 `/ src / backend / parser / gram.y` 下使用 bison.
  - 如果您着迷于这一结构，您也可以阅读 [postgreSQL数据库核心分析](https://book.douban.com/subject/6971366)。
  -
- ---
  - would use Repo
    collapsed:: true
    - https://github.com/WolfMy/course_select_system
    - https://github.com/yueht17/course_management_system
  - Django and Flask
    collapsed:: true
    - Diff: https://www.guru99.com/flask-vs-django.html
    - WSGI: The Web Server Gateway Interface (WSGI, pronounced whiskey or WIZ-ghee) is a simple calling convention for web servers to forward requests to web applications or frameworks written in the Python programming language. The current version of WSGI, version 1.0.1, is specified in Python Enhancement Proposal (PEP) 3333
    - https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface
    - https://wsgi.readthedocs.io/en/latest/