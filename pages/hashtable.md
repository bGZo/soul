alias:: data-structure/hash-table, 哈希表, 散列表
title:: hashtable

-
-
- Hash 碰撞解决方法
  collapsed:: true
  - [[Quickref]]
    - 平均查找长度
      id:: 6321e667-0a32-415c-aa68-a19b8311b879
      collapsed:: true
      - 依赖于散列表的装填因子 $α$，而不直接依赖于 $n$ 或 $m$
      - 装填因子 $α$, 定义为一个表的装满程度
        collapsed:: true
        - $$ α = \frac{n}{m}$$
        - 表中记录数 $n$;
        - 散列表长度 $m$;
      - ![image.png](../assets/algo/hashtable/image_1663168218242_0.png)
    - 优势
      id:: 6321ec2e-dac8-4e99-aa21-45f510ebf748
    - 局限
      id:: 6321e668-2026-467a-b6a5-a21f43027719
    - TODO 怎么确定最终查找到的数字 ± 1 ???
      collapsed:: true
      - 例如: 折半查找到最后一个元素的时候查找长度是?(4/5??)
        ```
        1  2  3  4  5  6  7  8  9  10  11  12
        4  3  2  3  4  1  3  4  2   3   4   5
        ```
  -
  - ((6321dbe7-2475-4f51-9a92-7ee9a54331a2)) #vs ((6320a0b1-bf68-4f58-a7e8-742fe589a943))
    collapsed:: true
    - ((6321dbe7-2475-4f51-9a92-7ee9a54331a2)) 把发生冲突的关键码存储在**散列表主表之外**;
    - ((6320a0b1-bf68-4f58-a7e8-742fe589a943)) 把发生冲突的关键码存储在**表中另一个槽内**
  -
  - **Open Hashing**
    id:: 6321dbe7-2475-4f51-9a92-7ee9a54331a2
    mark:: "Separate Chaining/开散列/链地址/拉链法, 在每个存放数据的地方开一个链表，如果有多个键值索引到同一个地方，只用把他们都放到那个位置的链表里就行了"
    collapsed:: true
    - ((6321e667-0a32-415c-aa68-a19b8311b879))
      collapsed:: true
      - 查找成功
      - 查找失败
    - ((6321ec2e-dac8-4e99-aa21-45f510ebf748))
      collapsed:: true
      - 处理简单，且无 ((6321db42-1a19-4b70-a5f1-bd24ece8448c)) 现象，即非同义词决不会发生冲突，因此平均查找长度较短；
      - 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
      - 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
      - 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点
    - ((6321e668-2026-467a-b6a5-a21f43027719))
      collapsed:: true
      - 指针需要额外的空间, 只有当结点规模较小时，开放定址法较为节省空间
        collapsed:: true
        - 需要空间的利用, 即考量 **指针节省的空间** 和 **扩大散列规模的空间**
          collapsed:: true
          最终目的/评判目的: 查找时间
          - 否则将**节省的指针空间**用来**扩大散列表的规模** -> 装填因子变小 -> ((6320a0b1-bf68-4f58-a7e8-742fe589a943)) 的冲突减少
  -
  - Closed Hashing
    id:: 6320a0b1-bf68-4f58-a7e8-742fe589a943
    mark:: Open Addressing/闭散列/开地址法
    collapsed:: true
    - 线性探测法
      mark:: "线性探测再散列; 即往后滚, 滚到 NULL 位就塞进去, 滚出去就从零开始滚"
      - 寻找下一散列地址公式
        - $$H_{i} = (H(key) + d_{i} ) \% m$$
          $$d_{i} = 1, 2, ..., m-1$$
        - 键值 $key$;
        - 设 $H(key)=d$;
        - 闭散列表的长度为 $m$;
        - ((6321e667-0a32-415c-aa68-a19b8311b879))
          id:: 6321e532-f4ef-4305-8e0e-703a92d9f4c4
          - 查找成功
          - 查找失败
      - ((6321e668-2026-467a-b6a5-a21f43027719))
        - **堆积**
          id:: 6321db42-1a19-4b70-a5f1-bd24ece8448c
          - 在处理冲突的过程中出现的**非同义词之间对同一散列地址争夺**的现象
    - 二次探测法
      mark:: 二次探测再散列
      collapsed:: true
      - 寻找下一散列地址公式
        - $$H_{i} = (H(key) + d_{i} ) \% m$$
          $$d_{i} = 1^{2}, -{1}^{2}, 2^{2}, -{2}^{2}, ..., q^{2}, q <= \frac{m}{2}$$
        - 键值 $key$;
        - 设 $H(key)=d$;
        - 闭散列表的长度为 $m$;
        - ((6321e667-0a32-415c-aa68-a19b8311b879))
          - 查找成功
          - 查找失败
    - 随机探测法
      mark:: 伪随机探测再散列
      collapsed:: true
      - 寻找下一散列地址公式 (**位移量**是一个随机数列)
        - $$H_{i} = (H(key) + d_{i} ) \% m$$
          $$d_{i} 是随机数列, i=1, 2, ..., m-1$$
      - ((6321e668-2026-467a-b6a5-a21f43027719))
        - 需要记录处理冲突时产生的随机数, 以便在查找时使用, 因此**额外的空间开销较大**
  -
  - 再哈希法
    collapsed:: true
    - 发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲
    - ((6321e668-2026-467a-b6a5-a21f43027719))
      collapsed:: true
      - 计算时间增加
  -
  - 建立一个公共溢出区
    collapsed:: true
    - 假设哈希函数的值域为 $[0,m-1]$
    - 设向量 $HashTable[0..m-1]$ 为基本表
    - 设立存储空间向量 $OverTable[0..v]$ 用以存储发生冲突的记录
-
- ## ((632dca8e-3286-4ea0-b0eb-f631076beece)) #Java
-
-
-
- Refs
  - [Hash table - Wikipedia](https://en.wikipedia.org/wiki/Hash_table)
  - [哈希表 - OI Wiki](https://oi-wiki.org/ds/hash/#%E6%8B%89%E9%93%BE%E6%B3%95)
  - [Hash碰撞](https://www.cnblogs.com/little-fly/p/7907935.html)
  - [解决Hash碰撞冲突方法总结_zeb_perfect的博客-CSDN博客_哈希碰撞的解决办法](https://blog.csdn.net/zeb_perfect/article/details/52574915)
  - [数据结构--散列 - 李林超博客 ~ 个人博客](https://lilinchao.com/archives/448.html)
-