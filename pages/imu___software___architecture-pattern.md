title:: imu/software/architecture-pattern
tags:: [[software/pattern]], [[software/architecture]]
-
-
- Outline
  - 软件体系架构
    collapsed:: true
    - 软件危机
      collapsed:: true
      - 表现
        collapsed:: true
        - 成本日益增长
        - 开发进度难以控制
        - 质量差
        - 维护困难
      - 原因
        collapsed:: true
        - 用户需求不明确
        - 缺乏正确的理论指导
        - 软件规模越来越大
        - 软件复杂度越来越高
      - 如何克服
        collapsed:: true
        - 技术
          - 采用基于重用的软件生产技术
        - 管理
          - 采用多维的工程管理模式
    - 软件工程要素 (3)
      collapsed:: true
      - 方法
        - 完成软件工程项目的技术手段
      - 工具
        - 为软件工程方法提供自动或半自动的软件支撑环境
      - 过程
        - 软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的
      -
    - 软件构件和重用
      collapsed:: true
      - 在两次或多次不同的软件开发过程中重复使用相同或相近软件元素的过程
        collapsed:: true
        - 软件元素
          - 程序代码
          - 测试用例
          - 设计文档
          - 设计过程
          - 需求分析文档
          - 领域知识
      - 构件
        collapsed:: true
        - 核心和基础
        - **语义完整、语法正确和有可重用价值的单位软件**
        - **软件重用过程中可以明确辨识的系统**
        - **语义描述、通讯接口和实现代码的复合体**
      - 重用
        collapsed:: true
        - 必要的手段
    - 建模的种类
      collapsed:: true
      - 结构模型
        - 这是一个最直观、最普遍的建模方法。以体系结构的构件、连接件和其他概念来刻画结构
      - 框架模型
        - 框架模型与结构模型类似，但它不太侧重描述结构的细节而更侧重于整体的结构
      - 动态模型
        - 动态模型是对结构或框架模型的补充，研究系统的“大颗粒”的行为性质
      - 过程模型
        - 过程模型研究构造系统的步骤和过程
      - 功能模型
        - 功能模型认为体系结构是由一组功能构件按层次组成，下层向上层提供服务
    - 4+1视图
      - 逻辑视图 / Logic View
        - 描述系统的**功能需求**
        - 最终用户
      - 处理视图 / Process View
        - 运行质量属性
          - 易用性
          - 性能性
          - 可伸缩性
          - 鲁棒性
          - 安全性
        - 系统集成人员
      - 开发视图 / Development View
        - 开发质量属性
          - 可扩展性
          - 可重用性
          - 可移植性
          - 易理解性
          - 易测试性
        - 编程人员
      - 物理视图 / Physical View
        - 安全
        - 部署需求
        - 系统工程人员
      - 场景视图 / 用例视图 / Scenarios
    - ??? 软件体系风格
      collapsed:: true
      - 经典软件体系结构风格
        collapsed:: true
        - 管道和过滤器
        - 数据抽象和面向对象组织
        - 基于事件的隐式调用
        - 构件不直接调用一个过程，而是触发或广播一个或多个事件。
        - 分层系统：层次系统组织成一个层次结构，每一层为上层服务，并作为下层客户。
        - 仓库系统及知识库
        - C2
          - 通过连接件绑定在一起的按照一组规则运作的并行构件网络。
      - 客户/服务器风格
        collapsed:: true
        - C/S 体系 (3)
          collapsed:: true
          - 数据库服务器
          - 客户应用程序
          - 网络
      - 三层客户/服务器风格
        collapsed:: true
        - 浏览器/服务器风格（B/S）
          - 上述三层应用结构的一种实现方式，其具体结构为：
          - 浏览器/Web服务器/数据库服务器。 基于B/S体系结构的软件，系统安装、修改和维护全在服务器端解决。
      - 公共对象请求代理体系结构
      - 正交软件体系结构
      - 基于层次消息总线的体系结构
      - 异构结构风格
  - GRASP模式, 通用职责分配软件模式
    collapsed:: true
    - 设计模式 / 设计原则
      collapsed:: true
      - 站在面向对象设计的角度，告诉我们怎样设计问题空间中的类与分配它们的行为职责，以及明确类之间的相互关系等，而不像 GoF模式 一样是针对特定问题而提出的解决方案
      - 因此GRASP站在一个更高的角度来看待面向对象软件的设计，它是GoF设计模式的基础
    - 基本原则 (9)
      collapsed:: true
      - 信息专家
      - 创建者
      - 低耦合
      - 高内聚
      - 控制器
      - 多态 / 类似Switch
      - 纯虚构
      - 间接性
      - 防止变异
  - GoF 23 种设计模式
    id:: 63491e18-813e-466e-b6ca-72d05fedbaf2
    - GoF (Gang of Four)
      collapsed:: true
      - ***Design Patterns: Elements of Reusable Object-Oriented Software***
        - 由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著
      - 四人组
    - 分类
      - 目的
        - 创建型 (5) -> **怎样创建对象**”，它的主要特点是“将对象的创建与使用分离”
          collapsed:: true
          - ==单例模式==
            - 确保某一个类只有一个实例，并且提供一个全局访问点
              - 当系统中只需要一个实例对象或者系统中只允许一个公共访问点，除了这个公共访问点外，不能通过其他访问点访问该实例时，可以使用单例模式
          - 原型模式
            - 在我们应用程序可能有某些对象的结构比较复杂，但是我们又需要频繁的使用它们，如果这个时候我们来不断的新建这个对象势必会大大损耗系统内存的，这个时候我们需要使用原型模式来对这个结构复杂又要频繁使用的对象进行克隆。
          - ==工厂方法模式== <- ((63086bae-4ac7-4894-8b66-48394655dbc1))兄弟
            - 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类
              - 工厂方法模式非常符合 "开闭原则"
              - 当需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须修改原有系统。
          - ==抽象工厂模式==
            id:: 63086bae-4ac7-4894-8b66-48394655dbc1
            - 所谓抽象工厂模式就是提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。
              - 他允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。
          - 建造者模式
            - 将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。适用于那些产品对象的内部结构比较复杂。建造者模式将复杂产品的构建过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，使得相同的创建过程能够创建不同的产品。
        - 结构型 (7) -> **如何将类或对象按某种布局组成更大的结构**
          collapsed:: true
          - 代理模式
            mark:: "给一个对象提供一个代理，并由代理对象控制对原对象的引用。它使得客户不能直接与真正的目标对象通信。代理对象是目标对象的代表，其他需要与这个目标对象打交道的操作都是和这个代理对象在交涉"
          - 适配器模式
            mark:: "将两个不同接口的类来进行通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器"
          - ==桥接模式== -> **抽象部分和实现部分隔离开来**
            mark:: "如果说某个系统能够从多个角度来进行分类，且每一种分类都可能会变化，那么我们需要做的就是讲这多个角度分离出来，使得他们能独立变化，减少他们之间的耦合. 所谓桥接模式就是讲抽象部分和实现部分隔离开来，使得他们能够独立变化"
          - 装饰模式
            mark:: "动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案"
          - 外观模式
            mark:: "我们都知道类与类之间的耦合越低，那么可复用性就越好，如果两个类不必彼此通信，那么就不要让这两个类发生直接的相互关系，如果需要调用里面的方法，可以通过第三者来转发调用"
          - 享元模式
            mark:: "在一个系统中对象会使得内存占用过多，特别是那些大量重复的对象，这就是对系统资源的极大浪费。享元模式对对象的重用提供了一种解决方案，它使用共享技术对相同或者相似对象实现重用"
          - ==组合模式==
            mark:: "组合多个对象形成树形结构以表示“整体-部分”的结构层次. 定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分，可以对他们进行一致的处理"
        - 行为型 (11) -> 类或对象之间**怎样相互协作, 分配职责**完成单个对象都无法单独完成的任务
          collapsed:: true
          - 模板方法模式
            - 有些时候我们做某几件事情的步骤都差不多，仅有那么一小点的不同，在软件开发的世界里同样如此，如果我们都将这些步骤都一一做的话，费时费力不讨好。所以我们可以将这些步骤分解、封装起来，然后利用继承的方式来继承即可，当然不同的可以自己重写实现嘛！这就是模板方法模式提供的解决方案。
          - 策略模式
            mark:: "我们知道一件事可能会有很多种方式来实现它，但是其中总有一种最高效的方式，在软件开发的世界里面同样如此，我们也有很多中方法来实现一个功能，但是我们需要一种简单、高效的方式来实现它，使得系统能够非常灵活"
          - 命令模式
            mark:: "有些时候我们想某个对象发送一个请求，但是我们并不知道该请求的具体接收者是谁，具体的处理过程是如何的，我们只知道在程序运行中指定具体的请求接收者即可，对于这样将请求封装成对象的我们称之为命令模式"
          - 职责链模式
            mark:: "职责链模式描述的请求如何沿着对象所组成的链来传递的。它将对象组成一条链，发送者将请求发给链的第一个接收者，并且沿着这条链传递，直到有一个对象来处理它或者直到最后也没有对象处理而留在链末尾端"
          - 状态模式
            mark:: "在很多情况下我们对象的行为依赖于它的一个或者多个变化的属性，这些可变的属性我们称之为状态，也就是说行为依赖状态，即当该对象因为在外部的互动而导致他的状态发生变化，从而它的行为也会做出相应的变化。所以状态模式就是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类"
          - ==观察者模式==
            mark:: "何谓观察者模式？观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。发生改变的对象称之为观察目标，而被通知的对象称之为观察者"
          - 中介者模式 ???
            mark:: "软件的世界里需要这样一个中间者。在我们的系统中有时候会存在着对象与对象之间存在着很强、复杂的关联关系，如果让他们之间有直接的联系的话，必定会导致整个系统变得非常复杂，而且可扩展性很差！在前面我们就知道如果两个类之间没有不必彼此通信，我们就不应该让他们有直接的关联关系，如果实在是需要通信的话，我们可以通过第三者来转发他们的请求。"
          - 迭代器模式
            mark:: "对于迭代在编程过程中我们经常用到，能够游走于聚合内的每一个元素，同时还可以提供多种不同的遍历方式，这就是迭代器模式的设计动机。在我们实际的开发过程中，我们可能会需要根据不同的需求以不同的方式来遍历整个对象，但是我们又不希望在聚合对象的抽象接口中充斥着各种不同的遍历操作，于是我们就希望有某个东西能够以多种不同的方式来遍历一个聚合对象，这时迭代器模式出现了"
          - 访问者模式
            mark:: "表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变"
          - 备忘录模式
            mark:: "备忘录模式就是一种后悔药，它给我们的软件提供后悔药的机制，通过它可以使系统恢复到某一特定的历史状态"
          - 解释器模式
            mark:: "定义语言的文法，并且建立一个解释器来解释该语言中的句子。解释器模式描述了如何构成一个简单的语言解释器，主要应用在使用面向对象语言开发的编译器中"
      - 作用范围
        - 类模式 (4) -> 用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了
          - 工厂方法
          - (类)适配器
          - 模板方法
          - 解释器
        - 对象模式 (19) -> 用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性
    - 设计模式
      - 一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结
      - 目的
        - 可重用代码、让代码更容易被他人理解、保证代码可靠性
      - 模式
        - 在某些场景下，针对某类问题的某种通用的解决方案
    - 基本成分
      collapsed:: true
      - 模式名称
        - 一个助记名，它用一两个词来描述模式的问题、解决方案和效果。
      - 问题
        - 描述了应该在何时使用模式。
      - 解决方案
        - 描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式。
      - 后果(效果)
        - 描述了模式应用的效果及使用模式应权衡的问题。
-
-
- Other
  - architecture
    - 架构 & 软件架构
      - 架构
        collapsed:: true
        - 规划、设计、构建的过程及最终成果
      - 软件架构
        collapsed:: true
        - “决策”论
          collapsed:: true
          - > 架构就是**一系列重要的决策**，这些决策涉及软件系统的组织、组成系统的结构化元素及其接口的选择、元素之间协作时特定的行为、结构化元素和行为元素形成更大子系统的组合方式以及引导这一组织（也就是这些元素及其接口）、他们之间的协作以及组合（架构风格）
            -- Booch, Rumbaugh和Jacobson, 1999
        - “组成”论
          collapsed:: true
          - > 程序或计算系统的软件架构是**系统的一个或多个结构**，它包括软件元素、这些元素的外部可见属性以及它们之间的关系
            -- SEI(Software Engineering Institute) Len Bass 等人
      - 架构 #vs 设计
        collapsed:: true
        - 架构是顶层设计
          - ↓ **流程**设计
            collapsed:: true
            - 操作层面
            - 用户从哪里进入、页面应该跳转到哪里、应该输入哪些信息...
          - ↓ **代码**设计
            collapsed:: true
            - 代码层面
            - 模块如何组织、包如何组织、类如何组织、方法如何组织...
          - ↓ **架构**设计
            collapsed:: true
            - 系统整体层面
            - 子系统如何组织、组件如何组织、接口如何设计...
    - 种类
      - 逻辑架构
        collapsed:: true
        - 软件系统中元件之间的关系，比如用户界面，数据库，外部系统接口、商业逻辑元件等
      - 物理架构
        collapsed:: true
        - 软件元件是怎样放到硬件上的
      - 系统架构
        collapsed:: true
        - 系统的非功能性特征，如可扩展性、强壮性、灵活性、可靠性、性能等
    - 表现形式 --> 4+1视图 <- 每种构架视图针对于开发流程中的涉众所关注的特定方面
      collapsed:: true
      id:: 63959db5-f30c-467a-970d-68960d208fae
      - ![image.png](../assets/imu/sa/image_1661437868975_0.png)
      - 逻辑视图 / Logic View
        - 描述系统的功能需求
        - 使用面向对象的分解方法，逻辑架构主要支持功能需求，也就是系统应该提供怎样的服务给用户。系统分解为一组关键抽象，如问题域的对象或对象类的形式。利用封装和继承的抽象原则。分解不仅是为了功能分析，也为了识别常见的服务机制和跨系统的设计元素。
        - ![image.png](../assets/imu/sa/image_1661438007970_0.png)
      - 处理视图 / Process View
        - 处理架构是考虑一些非功能性的需求，它可以解决并发性和分布系统的完整性与容错性等问题，主要指导如何从逻辑视图的抽象融入处理架构之中，比如哪个线程来控制对象的实际执行。
        - ![image.png](../assets/imu/sa/image_1661438083634_0.png)
      - 开发视图 / Development View
        - 开发架构侧重于软件开发环境中的实际软件模块组织。该软件以小块（程序库或子系统）打包，可以由一个或少数开发人员开发。子系统按层的层次结构进行组织，每层为其上方的层提供一个狭窄且定义明确的接口。系统的开发架构由模块和子系统图表示，显示了"导出"和"导入"关系。
        - ![image.png](../assets/imu/sa/image_1661438533503_0.png)
      - 物理视图 / Physical View
        - 物理体系结构主要考虑系统的非功能性要求，例如可用性、可靠性（容错）、性能（吞吐量）和可伸缩性。该软件在计算机网络或处理节点（或简称节点）上执行。识别的各种元素（网络、进程、任务和对象）需要映射到各种节点上。软件到节点的映射需要高度灵活，并且对源代码本身的影响最小。
        - ![image.png](../assets/imu/sa/image_1661438136223_0.png)
      - 场景视图 / 用例视图 / Scenarios
        - 四个视图中的元素共同通过使用场景来无缝地协同工作。从某种意义上说，这些方案是对最重要需求的抽象。此视图与其他视图（因此为"+1"）是多余的，但它有两个主要目的：
          - 作为在体系结构设计期间发现体系结构元素的驱动因素
          - 在此体系结构设计完成后作为验证和说明角色，无论是在纸上还是作为体系结构原型测试的起点。
      - 总结
        1.  4+1 视图模型采用用例驱动，在软件生命周期的各个阶段对软件进行建模，从不同视角对系统进行解读，从而形成统一软件过程架构描述
        2.  4+1 视图模型的每一个视图只关心系统的一个侧面，5个视图结合在一起反映系统的软件体系结构的全部内容。
        3.  4+1 视图模型的建模工具和符号的选择并没有统一规定。而UML中的图和各视图的对应关系如下:
        1.  逻辑视图：类图和对象图
        2.  开发视图：类图和组件图
        3.  处理视图：顺序图、协作图、状态图、活动图、组件图
        4.  物理视图：部署图
        5.  场景视图：用例图
        4.  4+1 视图模型能在许多大型项目中成功运用。事实是，它允许不同的"风险承担人"找出他们就软件架构所关心的问题。系统工程师首先接触物理视图，然后转向进程视图；最终用户、顾客、数据分析专家从逻辑视图入手；项目经理、软件配置人员则从开发视图来看待"4＋1"视图。
    - 目标
    - 作用
    - 常见软件架构
      collapsed:: true
      - 分层架构
      - 事件驱动架构
      - 微核架构
      - 微服务架构
      - 云架构
  - pattern
  -
- Mark
  - [备忘录模式实现撤销(Undo)和重做(Redo)功能_追梦*小生的博客-CSDN博客_undo撤销模块有什么用](https://blog.csdn.net/shiaiao/article/details/117790737)
    collapsed:: true
    - https://blog.csdn.net/shiaiao?type=blog
  - 多看实例!!!艸
-
- Refs
  - [软件架构基本概念_西秀的博客-CSDN博客_五种常见的软件架构](https://blog.csdn.net/qq_38179583/article/details/109008390)
    - [什么是软件架构 - 一瑜一琂 - 博客园](https://www.cnblogs.com/ivaneye/p/9752478.html)
    - [（五）什么是软件架构视图 4+1视图_taoge512的博客-CSDN博客_4+1视图](https://blog.csdn.net/taoge512/article/details/81224430)
    - [软件架构视图—4+1模式_maritimesun的博客-CSDN博客_软件体系结构4+1](https://blog.csdn.net/maritimesun/article/details/7099652)
  - ![4+1view-architecture.pdf](../assets/imu/sa/4+1view-architecture_1647196355125_0.pdf)
  - [13种常见软件体系结构风格定义分析、结构图、优缺点_devillyd2018的博客-CSDN博客_软件体系结构图](https://blog.csdn.net/devillyd2018/article/details/116919837)
  - [软件设计·体系结构设计(Architectual Design)_miracles_1000th的博客-CSDN博客_体系结构设计](https://blog.csdn.net/miracles_1000th/article/details/125419855)
-