icon:: 📖
cover:: {{image/cover https://img1.doubanio.com/view/subject/s/public/s33929048.jpg}}
also:: 创建优雅、富于表现力和高性能的JVM与Android应用程序
author:: 文卡特·苏布拉马尼亚姆
created:: [[20240807]]
exclude-from-graph-view:: true
isbn:: 9787111682752
lang:: chinese
published-date:: 20210620
rating:: ⭐⭐⭐⭐
status:: book/reading
tags:: #kotlin 
type:: book/dev
douban:: {{doubook 35506200}}
weread:: {{weread 376323a0724b925b376fe83}}

- ## Contents
  - 第1章 你好Kotlin
    collapsed:: true
    - 1.1 爱上Kotlin的理由
      - 1.1.1 多范式编程
      - 1.1.2 具有类型推断的静态类型
    - 1.2 为什么选择Kotlin
    - 1.3 带Kotlin去兜兜风
      - 1.3.1 安装Kotlin SDK
      - 1.3.2 验证安装
    - 1.4 编译成字节码并运行
      - 1.4.1 在命令行上运行
      - 1.4.2 在IDE中运行
      - 1.4.3 使用REPL进行实验
      - 1.4.4 作为脚本运行
    - 1.5 编译成其他目标
    - 1.6 选择哪个选项
    - 1.7 本章小结
  - 第一部分 使用Kotlin编写脚本
    background-color:: yellow
  - 第2章 从Java角度了解Kotlin的基本知识
    collapsed:: true
    - 2.1 减少输入
      - 2.1.1 分号是可选的
      - 2.1.2 变量类型规范是可选的
      - 2.1.3 类和函数是可选的
      - 2.1.4 try-catch是可选的
    - 2.2 合理的警告
    - 2.3 选择val而不是var
    - 2.4 改进的相等性检查
    - 2.5 字符串模板
    - 2.6 原始字符串
      - 2.6.1 没有转义
      - 2.6.2 多行字符串
    - 2.7 更多的表达式，更少的语句
    - 2.8 本章小结
  - 第3章 使用函数
    collapsed:: true
    - 3.1 创建函数
      - 3.1.1 KISS函数
      - 3.1.2 返回类型和类型推断
      - 3.1.3 所有的函数都是表达式
      - 3.1.4 定义参数
      - 3.1.5 带有块体的函数
    - 3.2 默认参数和命名参数
      - 3.2.1 演化带有默认参数的函数
      - 3.2.2 使用命名参数提高可读性
    - 3.3 vararg和spread
      - 3.3.1 可变数量的实参
      - 3.3.2 spread运算符
    - 3.4 解构
    - 3.5 本章小结
  - 第4章 外部迭代和参数匹配
    collapsed:: true
    - 4.1 范围与迭代
      - 4.1.1 范围类
      - 4.1.2 正向迭代
      - 4.1.3 反向迭代
      - 4.1.4 跳过范围内的值
    - 4.2 遍历数组和列表
    - 4.3 何时应该使用when
      - 4.3.1 when用作表达式
      - 4.3.2 when用作语句
      - 4.3.3 when和变量的作用域
    - 4.4 本章小结
  - 第5章 使用集合
    collapsed:: true
    - 5.1 集合的类型
      - 5.1.1 Kotlin所添加的便利方法
    - 5.1.2 视图
    - 5.2 使用Pair和Triple
    - 5.3 对象和基元数组
    - 5.4 使用列表
    - 5.5 使用集合
    - 5.6 使用映射
    - 5.7 本章小结
  - 第6章 使用类型安全性解决问题
    collapsed:: true
    - 6.1 Any和Nothing类
      - 6.1.1 Any是基类
      - 6.1.2 Nothing比void更深入
    - 6.2 可空的引用
      - 6.2.1 null是件不好的事
      - 6.2.2 使用可空类型
      - 6.2.3 安全调用运算符
      - 6.2.4 Elvis运算符
      - 6.2.5 不要使用不安全的断言运算符
      - 6.2.6 使用when
    - 6.3 类型检查和转换
      - 6.3.1 类型检查
      - 6.3.2 使用is
      - 6.3.3 智能转换
      - 6.3.4 使用带有when的类型检查和智能转换
    - 6.4 显式类型转换
    - 6.5 泛型：参数类型的变化和约束
      - 6.5.1 类型不变性
      - 6.5.2 使用协变
      - 6.5.3 使用逆变
      - 6.5.4 使用where的参数类型约束
      - 6.5.5 星投影
    - 6.6 具体化的类型参数
    - 6.7 本章小结
  - 第二部分 面向对象的Kotlin
    background-color:: yellow
  - 第7章 对象和类
    collapsed:: true
    - 7.1 对象和单例
      collapsed:: true
      - 7.1.1 带有对象表达式的匿名对象
      - 7.1.2 带有对象声明的单例
      - 7.1.3 顶级函数与单例
    - 7.2 创建类
      collapsed:: true
      - 7.2.1 最小的类
      - 7.2.2 只读属性
      - 7.2.3 创建实例
      - 7.2.4 读写属性
      - 7.2.5 底层探秘——字段和属性
    - 7.3 伴生对象和类成员
      collapsed:: true
      - 7.3.1 类级别成员
      - 7.3.2 访问同伴
      - 7.3.3 Companion作为Factory
      - 7.3.4 不是非常静态的
    - 7.4 创建泛型类
    - 7.5 数据类
    - 7.6 本章小结
  - 第8章 类层次结构和继承
    collapsed:: true
    - 8.1 创建接口和抽象类
      - 8.1.1 创建接口
      - 8.1.2 创建抽象类
      - 8.1.3 是接口还是抽象类
    - 8.2 嵌套类和内部类
    - 8.3 继承
    - 8.4 Sealed类
    - 8.5 创建和使用枚举
    - 8.6 本章小结
  - 第9章 通过委托进行扩展
    collapsed:: true
    - 9.1 何时选择委托而不是继承
    - 9.2 使用委托进行设计
    - 9.2.1 一个设计问题
    - 9.2.2 继承的错误指向
    - 9.2.3 委托——艰难的方式
    - 9.2.4 使用Kotlin的by来进行委托
    - 9.3 委托给一个参数
    - 9.4 处理方法冲突
    - 9.5 Kotlin委托的注意事项
    - 9.6 委托变量和属性
    - 9.6.1 委托变量
    - 9.6.2 委托属性
    - 9.7 内置的标准委托
    - 9.7.1 有点儿懒惰也没关系
    - 9.7.2 Observable委托
    - 9.7.3 行使你的可否决权利
    - 9.8 本章小结
  - 第三部分 函数式Kotlin
    background-color:: yellow
  - 第10章 使用lambda进行函数式编程
    collapsed:: true
    - 10.1 函数式风格
    - 10.1.1 什么是函数式风格
    - 10.1.2 为什么以及何时使用函数式风格
    - 10.2 lambda表达式
    - 10.2.1 lambda的结构
    - 10.2.2 传递lambda
    - 10.2.3 使用隐式参数
    - 10.2.4 接收lambda
    - 10.2.5 用lambda作为最后一个参数
    - 10.2.6 使用函数引用
    - 10.2.7 函数返回函数
    - 10.3 lambda和匿名函数
    - 10.4 闭包和词法作用域
    - 10.5 非局部和带标签的return
    - 10.5.1 默认情况下不允许使用return
    - 10.5.2 带标签的return
    - 10.5.3 非局部return
    - 10.6 带有lambda的内联函数
    - 10.6.1 默认情况下没有内联优化
    - 10.6.2 内联优化
    - 10.6.3 对参数精心选择noinline
    - 10.6.4 内联lambda中允许非局部return
    - 10.6.5 crossinline参数
    - 10.6.6 inline和return的良好实践
    - 10.7 本章小结
  - 第11章 内部迭代和延迟计算
    collapsed:: true
    - 11.1 外部迭代器与内部迭代器
    - 11.2 内部迭代器
    - 11.2.1 filter﹑map和reduce
    - 11.2.2 得到第一个和最后一个
    - 11.2.3 flatten和flatMap
    - 11.2.4 排序
    - 11.2.5 将对象进行分组
    - 11.3 延迟计算序列
    - 11.3.1 使用序列提高性能
    - 11.3.2 无限序列
    - 11.4 本章小结
  - 第四部分 优雅且高效的Kotlin
    background-color:: yellow
  - 第12章 Kotlin的流畅性
    collapsed:: true
    - 12.1 重载运算符
    - 12.2 使用扩展函数和属性进行注入
    - 12.2.1 使用扩展函数注入方法
    - 12.2.2 使用扩展函数注入运算符
    - 12.2.3 使用扩展属性注入属性
    - 12.2.4 注入第三方类
    - 12.2.5 注入静态方法
    - 12.2.6 从类内注入
    - 12.3 扩展函数
    - 12.4 带中缀的函数流畅性
    - 12.5 带Any对象的流畅性
    - 12.5.1 四种方法的行为
    - 12.5.2 来自冗长和混乱的代码
    - 12.5.3 使用apply删除重复的引用
    - 12.5.4 使用run获得结果
    - 12.5.5 使用let将对象作为参数传递
    - 12.5.6 使用also将void函数链接起来
    - 12.6 隐式接收方
    - 12.6.1 传递一个接收方
    - 12.6.2 带接收方的多个作用域
    - 12.7 本章小结
  - 第13章 创建内部DSL
    collapsed:: true
    - 13.1 DSL的类型和特征
    - 13.1.1 外部DSL与内部DSL
    - 13.1.2 语境驱动和流畅
    - 13.2 用于内部DSL的Kotlin
    - 13.2.1 分号可选
    - 13.2.2 点和圆括号不与中缀在一起
    - 13.2.3 使用扩展函数获得特定的域
    - 13.2.4 传递lambda不需要圆括号
    - 13.2.5 隐式接收方影响DSL的创建
    - 13.2.6 还有一些特性可以帮助DSL
    - 13.3 构建流畅性方面的挑战
    - 13.3.1 使用扩展函数
    - 13.3.2 使用接收方和中缀
    - 13.4 类型安全构建器
    - 13.4.1 HTML构建器
    - 13.4.2 XML构建器
    - 13.5 使用作用域控制来缩小访问范围
    - 13.6 本章小结
  - 第14章 编写递归和记忆
    collapsed:: true
    - 14.1 递归的威力和危险
    - 14.2 尾调用优化
    - 14.3 记忆
    - 14.3.1 重复计算
    - 14.3.2 记忆——Kotlin中的Groovy方法
    - 14.3.3 记忆作为委托
    - 14.4 将记忆应用于动态规划
    - 14.5 本章小结
  - 第五部分 编写异步应用程序
    background-color:: yellow
  - 第15章 探索协程
    collapsed:: true
    - 15.1 协程和并发
    - 15.1.1 并行与并发
    - 15.1.2 协程作为协作函数
    - 15.2 使用协程并发运行
    - 15.2.1 从顺序执行开始
    - 15.2.2 创建一个协程
    - 15.2.3 启动一个任务
    - 15.2.4 与挂起点交错调用
    - 15.3 协程上下文和线程
    - 15.3.1 显式设置上下文
    - 15.3.2 在自定义池中运行
    - 15.3.3 在挂起点后切换线程
    - 15.3.4 修改CoroutineContext
    - 15.4 调试协程
    - 15.4.1 async和await
    - 15.4.2 看一眼延续
    - 15.5 创建无限序列
    - 15.5.1 使用序列
    - 15.5.2 使用iterator函数
    - 15.6 本章小结
  - 第16章 异步编程
    collapsed:: true
    - 16.1 非阻塞异步编程
    - 16.1.1 按顺序开始
    - 16.1.2 进行异步
    - 16.2 异常处理
    - 16.2.1 启动和异常
    - 16.2.2 异步和异常
    - 16.3 取消和超时
    - 16.3.1 取消协程
    - 16.3.2 请勿打扰
    - 16.3.3 双向取消
    - 16.3.4 监督作业
    - 16.3.5 编程时使用超时
    - 16.4 本章小结
  - 第六部分 互操作和测试
    background-color:: yellow
  - 第17章 将Java与Kotlin混合使用
    collapsed:: true
    - 17.1 联合编译
    - 17.2 从Kotlin调用Java
    - 17.3 从Java调用Kotlin
    - 17.3.1 使用Java中的重载运算符
    - 17.3.2 创建静态方法
    - 17.3.3 传递lambda
    - 17.3.4 添加throws子句
    - 17.3.5 使用带默认参数的函数
    - 17.3.6 访问顶级函数
    - 17.3.7 更多注释
    - 17.4 本章小结
  - 第18章 使用Kotlin进行单元测试
    collapsed:: true
    - 18.1 被测试的代码
    - 18.2 获取项目文件
    - 18.2.1 设置Gradle
    - 18.2.2 设置Maven
    - 18.3 从Canary测试开始
    - 18.4 编写经验测试
    - 18.5 编写数据驱动的测试
    - 18.6 模拟依赖项
    - 18.6.1 创建交互测试
    - 18.6.2 测试解析数据
    - 18.7 测试顶级函数
    - 18.8 测试协程和异步调用
    - 18.9 与服务集成
    - 18.10 查看代码覆盖率
    - 18.11 将应用程序用于驱动
    - 18.12 本章小结
  - 第19章 使用Kotlin编写Spring应用程序
    collapsed:: true
    - 19.1 创建一个Starter项目
    - 19.2 创建一个控制器
    - 19.3 创建一个实体类
    - 19.4 创建一个存储库接口
    - 19.5 创建一个服务
    - 19.6 将服务与控制器集成
    - 19.7 继续实践
    - 19.8 本章小结
  - 第20章 使用Kotlin编写Android应用程序
    collapsed:: true
    - 20.1 创建一个项目
    - 20.2 定义域对象
    - 20.3 创建布局
    - 20.4 实施活动
    - 20.5 更新RecyclerView
    - 20.6 查看应用程序的运行情况
    - 20.7 本章小结
-