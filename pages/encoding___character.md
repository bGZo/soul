icon:: 📄
alias:: 代码页, 内码表, 字符编码
created:: 20240713
wikipedia:: https://en.wikipedia.org/wiki/Character_encoding

- ## Why
- ## How
- ## What
  - [[ascii]]
    - 计算机诞生于美国，只需要考虑他们那边的编码即可
    - 因为拉丁字符很少，加上一些控制命令，只用了 7 位，即 $$2^7 = 128$$
  - [[eascii]] (Extended)
    - 在 ascii 的基础上把最前一位二进制利用了起来，拓展 askii 码诞生；
  - [[gbk]]
    - 原理是用两位二进制数表示一个中文汉字，最多可以表示 $$2^{16} = 65,536$$ 个字符，结构为
    - $$0000,0000,0000,0000$$
    - 中国标准，这个字符集并没有得到世界统一，所以浏览别国电脑编码的文件，会有乱码的问题；
  - [[unicode]]
    - unicode 是规定了一个巨大的字符集，最多可以表示  $$2^{24} = 16,777,216$$
    - $$0000,0000,0000,0000,0000,0000$$
    - 实际几乎没有用到最前一位，表示范围是`0×00000`到`0x10FFFF`，即最多可以表示 $$2^{23} = 8,388,608$$
    - $$0001,0000,1111,1111,1111,1111$$
  - [[utf-8]]
    - 一种变长表示方式，使用 1\~4 个字节表示一个字符，以开头的特殊序列区分字符，映射关系如下：
    - |Unicode编码(16进制) |   UTF-8 字节流(二进制)|
      |`000000 – 00007F`   | `0xxxxxxx`|
      |`000080 – 0007FF`    |`110xxxxx 10xxxxxx`|
      |`000800 – 00FFFF`   | `1110xxxx 10xxxxxx 10xxxxxx`|
      |`010000 – 10FFFF`   | `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`|
  - 大小端，不同的处理器架构字节存放顺序不同， 如intel 全小端， amd 大小端都支持；
    #[[encoding/character/endian]]
  - BOM（byte-order mark）
    - unicode 编码中表示字节编码方式的头，区分如下:
    - |UTF编码   | Byte Order Mark|
      |UTF-8    |EF BB BF|
      |UTF-16LE   | FF FE|
      |UTF-16BE   | FE FF|
      |UTF-32LE   | FF FE 00 00|
      |UTF-32BE   | 00 00 FE FF|
    - 因为 BOM 一开始就是给 UTF-16 和 UTF-32 设计的，UTF-8 不参与这个游戏，所以其在大小端的机器上表示方式都一样，如字符 `你` `U+4F60`
    - ```shell
      # UTF-8
      0xE4 0xBD 0xA0
      # UTF-16
      0x4F 0x60 # BE
      0x60 0x4F # LE
      # UTF-32
      0x00 0x00 0x4F 0x60 # BE
      0x60 0x4F 0x00 0x00 # LE
      ```
    - 添加 BOM 是微软的习惯，所以 UTF-8 就分有无 BOM 的版本，但实际 BOM 屁用没有；
-
- ## Reference
  - https://zi-hi.com/
  - http://lovecn.github.io/utf8.html
  - https://gist.github.com/fanfeilong/844ad0c2e2654cfd4c7e
    collapsed:: true
    - EASCII
    - ISO 8859
      - ISO 8859-n(n=1,2,3,...,11,13,...,16)
      - Latin-1 == ISO8859-1
    - GB2312
      id:: 6d652964-9186-407d-bbae-464bee0b36a1
    - GBK(Chinese Internal Code Specification)
      - \> ((6d652964-9186-407d-bbae-464bee0b36a1))
    - BIG5 (small conflict with GB2312)
    - GB18030
      - \> ((6d652964-9186-407d-bbae-464bee0b36a1))
    - Unicode (NOT Compatible with GBXXX)
      - UCS2
      - UTF-16 (Extend UCS2)
      - UCS4
      - UTF-32 (Currently a subset of UCS4, But ability to encode more unicode characters)
      - UTF-8
        - BOM
        - No BOM
  - [ISO/IEC 8859 - Wikipedia](https://en.wikipedia.org/wiki/ISO/IEC_8859); [ISO/IEC 8859 - 維基百科，自由的百科全書](https://zh.wikipedia.org/wiki/ISO/IEC_8859)
  - [很多网站源码都是分为 GBK 和 UTF-8 版，为什么要同时开发两种？ - 知乎](https://www.zhihu.com/question/20209966/answer/676684648)
    collapsed:: true
    - 一直对字符的各种编码方式懵懵懂懂，什么ANSI UNICODE UTF-8 GB2312 GBK DBCS UCS……是不是看的很晕，假如您细细的阅读本文你一定可以清晰的理解他们。Let's go!
    - 很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为"字节"。
    - 再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为"计算机"。
    - 开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。
    - 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为"控制码"。他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的"Ascii"编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。
    - 后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称"扩展字符集"。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！
    - 等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的"全角"字符，而原来在127号以下的那些就叫"半角"字符了。
    - 中国人民看到这样很不错，于是就把这种汉字方案叫做 "GB2312"。GB2312 是对 ASCII 的中文扩展。但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。
    - 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。
    - 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 "DBCS"（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍：
    - "一个汉字算两个英文字符！一个汉字算两个英文字符……"
    - 因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个"汉字系统"，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么"倚天汉字系统"才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？
    - 真是计算机的巴比伦塔命题啊！正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它"Universal Multiple-Octet Coded Character Set"，简称 UCS, 俗称 "UNICODE"。
    - UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些“半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于"半角"英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。
    - 这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从 UNICODE 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的"一个字符"！同时，也都是统一的"两个字节"，请注意"字符"和"字节"两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。
    - 从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。
    - 但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！
    - UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到UTF时并不是直接的对应，而是要过一些算法和规则来转换。受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构，而另一些是采用高位先发送的方式，在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送"FEFF"，反之，则发送"FFFE"。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？
    - 讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入"联通"两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。
    - 从网上引来一段从UNICODE到UTF8的转换规则：
    - > Unicode
      > UTF-8
      > 0000 - 007F
      > 0xxxxxxx
      > 0080 - 07FF
      > 110xxxxx 10xxxxxx
      > 0800 - FFFF
      > 1110xxxx 10xxxxxx 10xxxxxx
    - 例如"汉"字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。而当你新建一个文本文件时，记事本的编码默认是ANSI, 如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，"联通"的内码是：
    - > c1 1100 0001
      > aa 1010 1010
      > cd 1100 1101
      > a8 1010 1000
    - 注意到了吗？第一二个字节、第三四个字节的起始部分的都是"110"和"10"，正好与UTF8规则里的两字节模板是一致的，于是再次打开记事本时，记事本就误认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了"00001 101010"，再把各位对齐，补上前导的0，就得到了"0000 0000 0110 1010"，不好意思，这是UNICODE的006A，也就是小写的字母"j"，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有"联通"两个字的文件没有办法在记事本里正常显示的原因。而如果你在"联通"之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个utf8编码的文件，而会用ANSI的方式解读之，这时乱码又不出现了。
    - 在数据库里，有n前缀的字串类型就是UNICODE类型，这种类型中，固定用两个字节来表示一个字符，无论这个字符是汉字还是英文字母，或是别的什么。如果你要测试"abc汉字"这个串的长度，在没有n前缀的数据类型里，这个字串是7个字符的长度，因为一个汉字相当于两个字符。而在有n前缀的数据类型里，同样的测试串长度的函数将会告诉你是5个字符，因为一个汉字就是一个字符。
  - [为何微软不把 Windows 的默认字符集设置成 Unicode ？](https://www.zhihu.com/question/24103924/answer/26688840)
    collapsed:: true
    - > **Windows内核中默认使用的是UTF-16**，如果你写内核驱动就知道了，在内核里几乎都是以UTF-16的方式处理字符串的。
      > 对于运行在应用层（用户态）的代码，Windows允许用户通过配置确定非Unicode字符的显示方式，可以是中文，也可以是BIG5，也可以是其它字符集。
      > 为什么这么设计？因为是考虑到兼容性的问题，现在Windows7里，仍然能运行大量Windows 98时代的程序，WindowsXP里甚至能运行不少Windows3.x甚至更古老的程序，原因就是为了兼容性。
      > 题主喜欢UTF-8，应该从Linux开发转过来的吧？Linux默认我记得是UTF-8（好像JSP也是？），UTF-8和UTF-16哪个更好我就不细说了，这方面的争论至今都没有结果。但是Windows可以把应用设置成UTF-16，之后的开发几乎没有太多的改变，我也没遇到过“**这不仅导致开发程序复杂**”的情况，至少C语言开发是这样的。所以，我看不出来UTF-16带来多少开发程序的不便。
      > 为什么用UTF-16？好像UTF-16出现的比UTF-8要早一些，微软内核选择了UTF-16，再大改内核是非常困难的，大概是这样的。
      > 如果题主是想讨论UTF-8和UTF-16哪个更好，建议再开个题目。
      > 补充，反对 [@赵冬毓](http://www.zhihu.com/people/a38ac6b1ee685ea2d586c355e0e11902) 的回答，国家标准中只强调支持，而没有强调必须默认使用，“must conform”是“要求符合”，而没有强调默认使用（default）这个字符集，工信部的那个规范里也没有强调默认使用这一点。
      > 遵循国家标准，也可以是把国家标准作为操作系统的子集，因为Linux、MacOS均支持GB18030，并且这个默认支持的行为不需要每次开机都提示，只需要在安装时告之即可。而且微软也做过类似的事情：在欧洲销售的WindowsXP在安装的时候都有浏览器的选择，并提供了Firefox等其它浏览器的下载链接，这也是微软为了提供告之义务以规避当地的反垄断法规。而且微软即使保持对GB18030默认支持，对于兼容性来说也没有问题，既遵守法律，又保持兼容性，未尝不可。
      > 另外，附上标准全文：[信息处理产品中文要求认证实施规则](https://link.zhihu.com/?target=http%3A//www.doc88.com/p-29324427457.html)
      > 以及维基百科上的说明：[GB 18030](https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/GB18030)
      > 以及检测标准：
      > > 检测一般要求如下：
      > >
      > > 　　●字汇完整性：产品的字汇范围应是国家标准GB 18030中所有给出字形的字符；
      > >
      > > 　　●体系正确性：产品必须能够正确识别和处理按照国家标准GB 18030进行编码的文本文件。
  - [在 Windows 下键入 Enter 键，是在键盘缓冲区中存入 '\n' 还是 '\r''\n' 两个？](https://www.zhihu.com/question/24639606/answer/28476223)
    collapsed:: true
    - > Windows不是一次设计完的，历经30多年的变迁积累了很多东西，其中一个特点就是vk（虚拟按键？），这是一个DWORD（32bit）类型的数据，用来描述各种键盘状态，因为一个面向事件的系统就必须要能处理各种按键的弹起、落下、组合键，而如果考虑到各种地区的键盘布局（比如欧洲地区的键盘布局），这种键位组合数量庞大，所以才用DWORD表示。而后来软件又希望提供directIO以及各种hook请求，就慢慢演变成如今这种这么复杂的东西。
      > 以一个USB键盘为例，从USB的请求开始到最终窗口收到消息，中间有好几层缓冲区，每层都不太一样。
      > 1. USB驱动一层有缓冲区，**扫描码，不区分换行符**。如果是使用directX的directIO进行按键输入管理，那么这一层就可以直接把按键信息拿走，有些游戏（比如LOL）就是这么做的。所有键盘消息最终都发送到Windows键盘的一个统一驱动里叫kbdclass.sys，这个驱动负责统一翻译、处理、管理所有键盘以及消息。这一层，应该还是扫描码。
      > 2. 之后，这个**消息就通过内核到用户态了**。在用户态里，进程csrss.exe有一个线程win32k!RawInputThread负责处理按键，广播按键消息。**此时扫描码变成按键（包括区域符号转化）**是"\n"
      > 3. csrss.exe调用DispatchMessage等函数分发消息给各个窗口、线程等。各个窗口收到按键消息，此时仍然是"\n".
      > 4. 部分窗口会根据按键消息做文本转换，转换完以后，看到的才是"\r\n".
      > 5. 对于命令行的C语言，由Windows的POSIX子系统或者其它模块负责接收按键消息，在LibC一层通过stdio/stdlib这些库转化成"\r\n".
      > 6. 所以，如果你操作的内容位于文本框（以及其它Windows文本环境）、命令行的LibC环境（包括但不限于stdio、iostream库），那么收到的应该是"\r\n"，其它情况，比如Windows按键消息等，多数收到的都是"\n"
      > 7. 当然，如果在MS开发环境下，真正到具体使用中的时候，还是分很多情况的：比如字符串"\n"在以非binary方式写入文件的时候，是"\r\n"，在以binary写入文件的时候，是"\n"，getchar返回的是"\n"，但不是绝对的，要根据你输入的数据流决定，有时候，如果输入的数据流是文件，而非键盘控制台，那么文件里的"\r\n"到了你的函数里，就变成了"\n"。所以，一个字符流可能保存在内存里的时候是"\r\n"，但你getchar得到的是"\n"，写到文件里却是"\r\n"。
      > 8. 所以，只能说，用实践去尝试，尤其做开发，甚至会出现不同的开发环境里返回值不同的情况。如果非要做严格检查，建议同时检查"\r\n", "\n\r", "\n", "\r"另附上Windows按键消息的处理流程：一个按键的消息产生流程如下：
      >     1. 硬件中断/硬件端口数据 `//WinIO能模拟，或者修改IDT是在这一层`
      >     2. 键盘Port驱动（USB or PS/2）
      >         ```
      >         //Filter驱动在此
      >         //DirectIO在此
      >         //KeyboardClassServiceCallback也在这一层被调用
      >         ```
      >     3. kbdclass驱动
      >         //处理键盘布局和键盘语言，部分高端的病毒也工作在这里
      >     4. Windows内核边界（zwCreate/zwReadFile）
      >         ----------------------（系统调用）----------------------
      >     5. Windows内核边界（zwCreate/zwReadFile）
      >     6. csrss.exe的win32k!RawInputThread读取，完成scancode和vk的转换
      >         ```
      >     //SetWindowHook工作在这里（全局）
      >         //kbd_event工作在这里
      >         ```
      >     7. csrss.exe调用DispatchMessage等函数分发消息
      >         ```
      >         //SetWindowHook工作在这里（进程）
      >         //PostMessage和SendMessage在这里
      >         ```
      >     8. 各个进程处理消息
      >     9. 子系统、LibC、文本框、输入法转换按键到最终字符（符号）