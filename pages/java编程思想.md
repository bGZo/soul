also:: books/Java编程思想

- ## Profile
  - > “上帝赋予人类说话的能力，而言语又创造了思想，思想是人类对宇宙的量度。 " --摘自《Prometheus Unbound》，Shelley
  - > 人类……极其受那些已经成为社会表达工具的特定语言的支配。想像一下，如果一个人可以不使用语言就能够从本质上适应现实世界，语言仅仅是解决具体的交流和反映问题时偶尔才用到的方式，我们会发现，这只能是一种幻想。事实上，“真实世界”在很大程度上是不如不觉地基于群体的语言习惯形成的。 --摘自《The Status of Linguistics As A Science）》，1929，Edward Sapir
  - “真实世界”在很大程度上是不知不觉地基于群体的语言习惯形成的。
  - 如同任何人类语言一样，Java提供了一种表达概念的方式。如果使用得当，随着问题变得更庞大更复杂，这种表达工具将会比别的可供选择的语言更为简单、灵活。
  - 当你开始设计一个系统时，应该认识到程序开发是一种增量过程，犹如人类的学习一样，这一点很重要。程序开发依赖于实验，你可以尽己所能去分析，但当你开始执行一个项目时，你仍然无法知道所有的答案。如果将项目视作是一种有机的、进化着的生命体去培养，而不是打算像盖摩天大楼一样快速见效，就会获得更多的成功和更迅速的回馈。
  - 为了在自己的程序中有效运用多态乃至面向对象的技术，必须扩展自己的编程视野，使其不仅包括个别类的成员和信息，而且还要包括类与类之间的共同特性以及它们之间的关系。尽管这需要极大的努力，但是这样做是非常值得的，因为它可以带来更多成效：更快的程序开发过程、更好的代码组织、更好扩展的程序以及更容易维护的代码。
- ## 对象
  - > “我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协定的参与者，这个协定以语言的形式固定下来…除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈。" -- Benjamin Lee Whorf（1897 ~ 1941）
  - __抽象__
    - 汇编语言
      - 底层的轻微抽象
    - 「命令式」语言
      - C、BASIC
      - 对汇编的抽象
      - 解决问题时
      - 基于计算机的结构
      - 不是基于所要解决的问题的结构
    - 只针对待解决问题建模
      - 世界的某些特定视图
      - LISP
      - 所有问题最终都是列表
      - APL
      - 所有问题都是算法形式的
      - 不能解决所有问题
      - 面向对象 OOP
      - 表示问题空间的元素
      - 不会受限于任何特定类型的问题
  - __每个对象一个接口__
    - 类
      - 问题空间的元素↔解空间的对象
    - 接口
      - 确定对某一特定对象，所能发出的请求
    - 每个对象都提供服务
      - 把对象想象成“服务提供者”
        如果我可以将问题从表象中抽取出来，那么什么样的对象可以马上解决我的问题呢？
      - 开发或理解程序
      - 提高「内聚性」，不试图做更多的事
  - __被隐藏的具体实现__
    - 访问控制
      - 让客户端程序员无法触及他们不应该触及的部分
      - 允许类库设计者改变内部的工作方式
    - 关键字
      - public
      - 任何类可用
      - private
      - 仅自己可访问
      - protected
      - 继承的类可访问
      - default
      - 同一个包可访问
  - __复用具体实现__
    - 组合
      - 现有的类→新的类
      - 极大的灵活性
    - 继承
      - 编译器→继承的类→编译时的限制
      - 继承
        - 基类和导出类差异
          - 直接在导出类添加新方法
          - 覆盖
  - __“是一个” 与 “像是一个” 关系__
    - __是一个__
      - 继承只覆盖基类
      - 纯粹替代
    - __像是一个__
      - 在导出类型→新的接口元素
  - __伴随多态的可互换对象__
    - 特定类型→基类对象
      - 不依赖特定类型的代码
    - 函数调用
      - 前期绑定
      - 非面向对象编程
      - 运行代码的绝对地址
      - 后期绑定
      - 面向对象编程
      - 编译器→确保调用方法的存在
      - 运行时→计算代码的地址
    - Java编译器
      - how？
      - 对象中存储信息→计算方法地址
      - 动态绑定是默认的
      - C++需要virtual关键字
    - 向上转型
      - 当向一个对象发送消息时，即使涉及向上转型，该对象也知道要执行什么样的正确行为。
      - 导出类→基类
      - 单根继承结构
        - 好处
          - 保证所有对象具有某些功能
            - 极大简化参数传递
            - 容易实现垃圾回收
  - __容器__
    - 如果不知道在解决某个特定问题时需要多少个对象，或者它们将存活多久，那么就不可能知道如何存储这些对象。
    - 集合
      - List
      - 存储序列
      - Map
      - 关联数组
      - Set
      - 集合
    - 泛型
      - 向下转型：Object→具体类型
        ![desc](file:///C:/Users/15517/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)
        - 参数化类型
    - 对象的创建和生命期
      - C++
        - 追求最大的执行速度
        - 编写时确定：储存空间、生命周期
        - 存储
        - 堆栈
        - 静态存储区
  - __Java__
    - 存储
    - 堆的内存池
    - 逻辑假设
      对象趋于变得复杂，所以查找和释放存储空间的开销，不会对对象的创建造成重大冲击。
  - __异常处理：处理错误__
    - 错误→置于编程语言中
      异常是一种对象从出错地点“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”，异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一个路径。
    - Java内置异常处理，并强制使用
-
- ## 一切都是对象
  - > 如果我们说另一种不同的语言，那么我们就会发觉一个有些不同的世界 --Luduing Wittgerstein（1889-1951）
  - **基本功:**  将思想转换到面向对象的世界中来.  即从 **指针 操作元素**变为 **对象 操作元素**.
  - 用引用操控对象
    - 对象可不可以理解成为物品, 而我们就是一个造物主
      **[争议] :** Java 对象的标识符 和 C--的对象引用
    - 遥控器（引用）→电视机（对象）
  - 必须由你创建所有对象
    - 存储地点
      - 寄存器
      - 处理器的寄存器，速度最快
      - 不能直接控制
      - 堆栈
      - 通用RAM中
      - Java对象引用
      - 堆
      - 通用内存池
      - Java对象
      - 常量存储
      - 程序代码内部
      - ROM（只读存储器）
      - 非RAM存储
      - 流对象
      - 持久化对象
    - 特例：基本类型
      - boolean
      - char
      - byte
      - shor
      - int
      - long
      - float
      - double
      - void
    - 高精度数字
      - BigInteger
      - BigDecimal
    - Java中的数组
      - 自动初始化
      - 范围检查
      - 少量的内存开销
      - 运行时的下标检查
  - 永远不需要销毁对象
    - 作用域和 C++ 不一样,  括号嵌套不可以有相同变量的存在(重命名),  而所谓的局部变量会一直占用空间
    - Java 具有智能的垃圾回收制度,  你只管 new 对象,  我给你擦屁股
  - 创建新的数据类型：类
    - 初始化
      - 类成员的基本数据类型→初始化
      - 非类字段→不初始化
  - 第一个Java程序
    - java.lang 类会自动被导入到每一个Java文件中;
    - JDK: 来自Sun公司, Java Developer's Kit，Java开发人员工具包,  用来编译运行 .java
      Jlikes: 来自 IBM , 比JDK要快.
    - > 每一章都有一名为build.xml的文件，该文件提供一个"ant"命令，用于自动构建该章的所有文件。Build文件和Ant（以及在哪里下载）在http:/MindView.net/Books/BetterJava所提供的补充材料中进行了完备而详细的讨论。一旦安装好Ant（可从http://jakara.apache.org/ant下载），便可直接在命令行提示符下键入ant来编译和运行每一章的程序了。如果尚未安装Ant，只要手工键入javac和java命令即可安装。
    - 名字的可见性
      - "名字" 间的冲突问题,  C++提供 名空间(namespace) 来解决;  Java 使用 **反转域名** 的方式 --> 确保唯一
    - Import
      - Java没有了 “向前引用” 的问题,  同文件夹下可以直接使用这个类, 使用 Import 导入一个类库(类, 方法和数据),  导入类
    - Static 关键字
      - Static字段 对 每个类 来说都只有一份存储空间;  非 Static 对 每个对象都有一份存储空间.
      - 静态字段: 类共享
      - 静态方法:
      - static方法的一个重要用法就是在不创建任何对象的前提下就可以调用它。正如我们将会看到的那样，这一点对定义main0方法很重要，这个方法是运行一个应用时的入口点。和其他任何方法一样，static方法可以创建或使用与其类型相同的被命名对象，因此，static方法常常拿来做“牧羊人”的角色，负责看护与其隶属同一类型的实例群。
    - 嵌入式文档
      - 注释继承 C/C++ . 而嵌入式文档要求 Java 提取有用的注释信息 -- javadoc
      - > javadoc 是用于提取注释的工具，是JDK安装的一部分。采用了Java编译器的某些技术，查找程序内的特殊注释标签。它不仅解析由这些标签标记的信息，也将毗邻注释的类名或方法名抽取出来。如此，我们就可以用最少的工作量，生成相当好的HTML程序文档，可以用Web浏览器查看。这样，该工具就使得我们只需创建和维护单一的源文件，并能自动生成有用的文档。有了javadoc，就有了创建文档的简明直观的标准，我们可以期望、甚至要求所有的Java类库都提供相关的文档。
        > 此外，如果想对javadoc处理过的信息执行特殊的操作（例如，产生不同格式的输出），那么可以通过编写你自己的被称为"doclets"的javadoc处理器来实现。
      - **语法:** 识别 **"/\*\*"**
      - **使用方式:**
        - 嵌入HTML
        - 文档标签
          - **Javadoc标签: **
            | **标签**      |                           **描述**                           |                           **示例**                           |
            | :------------ | :----------------------------------------------------------: | :----------------------------------------------------------: |
            | @author       |                       标识一个类的作者                       |                     @author description                      |
            | @deprecated   | 指名一个过期的类或成员; 该标签用于指出一些旧特性已由改进的新特性所取代，建议用户不要再使用这些旧特性，因为在不久的将来它们很可能会被删除。如果使用一个标记为@deprecated的方法，则会引起编译器发布警告。<br/>在Java SE5中，Javadoc标签@deprecated已经被@Deprecated注解所替代（我们将在第20章中 |                   @deprecated description                    |
            | {@docRoot}    | 指明当前文档根目录的路径; 产生到文档根目录的相对路径，用于文档树页面的显式超链接。 |                        Directory Path                        |
            | @exception    |                     标志一个类抛出的异常                     |            @exception exception-name explanation             |
            | {@inheritDoc} | 从直接父类继承的注释;从当前这个类的最直接的基类中继承相关文档到当前的文档注释中。 |      Inherits a comment from the immediate surperclass.      |
            | {@link}       |                  插入一个到另一个主题的链接                  |                      {@link name text}                       |
            | {@linkplain}  |     插入一个到另一个主题的链接，但是该链接显示纯文本字体     |          Inserts an in-line link to another topic.           |
            | @param        | 说明一个方法的参数; 该标签用于方法文档中，可以使用任意多个这种标签，大约每个参数都有一个这样的标签。 |              @param parameter-name explanation               |
            | @return       |                        说明返回值类型                        |                     @return explanation                      |
            | @see          | 指定一个到另一个主题的链接; 引用其他类;  @see标签允许用户引用其他类的文档。javadoc会在其生成的HTML文件中，通过@see标签链接到其他文档。 |                         @see anchor                          |
            | @serial       |                      说明一个序列化属性                      |                     @serial description                      |
            | @serialData   |    说明通过writeObject( ) 和 writeExternal( )方法写的数据    |                   @serialData description                    |
            | @serialField  |                说明一个ObjectStreamField组件                 |              @serialField name type description              |
            | @since        | 标记当引入一个特定的变化时; 允许你指定程序代码最早使用的版本，可以在HTMLJava文档中看到它被用来指定所用的JDK版本的情况。 |                        @since release                        |
            | @throws       | 和 @exception标签一样.“异常”将在第9章论述。简言之，它们是由于某个方法调用失败而“抛出”的对象。尽管在调用一个方法时；只出现一个异常对象，但是某个特殊方法可能会产生任意多个不同类型的异常，所有这些异常都需要进行说明。 | The @throws tag has the same meaning as the @exception tag.  |
            | {@value}      |            显示常量的值，该常量必须是static属性。            | Displays the value of a constant, which must be a static field. |
            | @version      |                         指定类的版本                         |                        @version info                         |
    - ```java
      @see classname
      @see fully-qualified-classname
      @see fully-qualified-classname#method-name
      //上述每种格式都会在生成的文档中加入一个具有超链接的"See Also"（参见）条目。但是javadoc不会检查你所提供的超链接是否有效。
      @author author-information //如果javadoc命令行使用了-author标记，那么就从生成的HTML文档中特别提取作者信息。可以使用多个标签，以便列出所有作者，但是它们必须连续放置。全部作者信息会合并到同一段落，置于生成的HTML中。
      @version version-information//可以是任何你认为适合包含在版本说明中的重要信息; 如果javadoc命令行使用了"-version"标记，那么就从生成的HTML文档中特别提取出版本信息。
      @return description//其中，“description”用来描述返回值的含义，可以延续数行。
      @param parameter-name description//parameter-name是方法的参数列表中的标识符，description是可延续数行的文本，终止于新的文档标签出现之前。
      @throws fully-qualified-class-name description//其中fully-qualified-class-name给出一个异常类的无歧义的名字，而该异常类在别处定义。description（同样可以延续数行）告诉你为什么此特殊类型的异常会在方法调用中出现。
      ```
      - `{@link package.classmember label}`: 用于行内，并且是用"label"作为超链接文本而不用"See Also".
      - 第一行采用我自己独特的方法，用一个作为特殊记号说明这是包含源文件名的注释行。该行包含文件的路径信息（此时，object代表本章），随后是文件名。最后一行也是一行注释，这个"ll"标志源代码清单的结束。自此，在通过编译器和执行检查后，文档就可以自动更新成本书的文本。Output标签表示输出的开始部分将由这个文件生成，通过这种形式，它会被自动地测试以验证其准确性。在本例中，（55%match）在向测试系统说明程序的每一次运行和下一次运行的输出存在着很大的差异，因此它们与这里列出的输出预期只有55%的相关性。本书中能够产生输出的大部分示例都包含这种注释方式的输出，因此你可以查看它们的运行输出，并知晓其正确性。
      - **编码风格:** 类名的首字母要大写，如果类名由几个单词构成，那么把它们并在一起（也就是说，不要用下划线来分隔名字），其中每个内部单词的首字母都采用大写形式。
-
- ## 操作符
-
- ## 初始化和清理
  - 构造(器) 函数(constructor)
    - > Java中也采用了构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。
      > 和 C-- 相同
      > <br>
    - 作用
      - 确保每个对象初始化
      - 调用构造器，是编译器的责任
    - 重载
      > 大多数人类语言具有很强的“冗余”性，所以即使漏掉了几个词，仍然可以推断出含义。不需要对每个概念都使用不同的词汇-从具体的语境中就可以推断出含义。
      - 大多数程序设计语言（尤其是C）要求为每个方法（在这些语言中经常称为函数）都提供一个独一无二的标识符, 重载采用参数列表不同的形式。
      - 如果传人的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。
      - 如果传入参数较大且无法做"窄化"处理, 编译器才会报错
        注: 和 C-- 一样, 没有返回值重载这么一说.
  - this关键字
    - **Q:**`a.peel(1), b.peel(2)`如何识别
      > **A:**
      >
      > 为了能用简便、面向对象的语法来编写代码-即“发送消息给对象”，编译器做了一些幕后工作。它暗自把“所操作对象的引用”作为第一个参数传递给peel()
      >
      > 假设你希望在方法的内部获得对当前对象的引用。由于这个引用是由编译器“偷偷”传入的，所以没有标识符可用。但是，为此有个专门的关键字：this，this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用.this的用法和其他对象引用并无不同。但注意，**如果在方法内部调用同一个类的另一个方法，就不必使用this，直接调用即可**。
      >
      > 由于函数成员通过this关键字返回了对当前对象的引用，所以很容易在一条语句里对同个对象执行多次操作。即对多个函数进行嵌套处理.
      > <br>
      > **Static 关键字**(Page 86)
      > 在static方法的内部不能调用非静态方法，反过来倒是可以的.
      > 并不是完全不可能。如果你传递一个对象的引用到静态方法里（静态方法可以创建其自身的对象），然后通过这个引用（和tis果相同），你就可以调用非静态方法和访问非静态数据成员了。但通常要达到这样的效果，你只需写一个非静态方法即可。
      > static全局变量 和 面向对象 的天然冲突???
      > 的确，要是在代码中出现了大量的statie方法，就该重新考虑自己的设计了。然而，static的概念有其实用之处，许多时候都要用到它。至于它是否真的“面向对象”，就留给理论家去讨论吧。事实上，Smallalk语言里的“类方法”就是与static方法相对应的。
  - 清理：终结处理和垃圾回收
    - GC仅负责new出来的对象; “本地方法”分配的内存，GC无法回收
    - finalize() : GC (Garbage Collection) 前，调用 finalize();  GC，回收对象内存
      > 一旦 GC(garbage collector) 准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。
      >
      > 1. 对象可能不被垃圾回收。
      > 2. 垃圾回收并不等于“祈构”。垃圾回收只与内存有关
      > 3. 绝对不能直接调用finalize()
    - > 这意味着在你不再需要某个对象之前，如果必须执行某些动作那么你得自己去做。也许你会发现，只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到解放。如果程序执行结束，并且垃圾回收器一直都没有释放你创建的任何对象的存储空间，则随着程序的退出，那些资源也会全部交还给操作系统。这个策略是恰当的，因为垃圾回收本身也有开销，要是不使用它，那就不用支付这部分开销了。
      > **如何工作?**
      > 存储空间的释放竟然会影响存储空间的分配，是某些Java虚拟机的工作方式。这也意味着，Java从堆分配空间的速度，可以和其他语言从堆栈上分配空间的速度相媲美。
  - 对象的创建过程
    - 首次创建Dog对象、访问Dog静态方法，Java解释器定位Dog.class
    - 载入Dog.class，静态初始化
    - new Dog()时，在堆上分配空间
    - 存储空间清零
      - 基本类型→默认值
      - 引用→null
    - 执行字段定义处的初始化动作
    - 执行构造器
  - ### 5.5.    初始化
    - **静态初始化**
      - static{}
      - 首次加载类时执行（即使未生成类对象）
    - **非静态初始化**
      - {}
      - 生成对象时执行，匿名内部类的初始化
    - **构造器（最后执行）**
  - 枚举类型
    - **enum类→编译器行为**
      **特性**
    - toString()
    - ordinal()
    - 特定enum常量的声明顺序
    - values()
    - 按顺序生成数组
  -