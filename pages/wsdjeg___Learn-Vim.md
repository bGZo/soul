title:: wsdjeg/Learn-Vim
tags:: #Github #opensource #vim #tutorial
mark:: [GitHub - wsdjeg/Learn-Vim_zh_cn](https://github.com/wsdjeg/Learn-Vim_zh_cn) ![](https://img.shields.io/github/stars/wsdjeg/Learn-Vim_zh_cn)

- ## Start
  - `option`/`flag` -> use flag to set options
    collapsed:: true
    - `:version`
    - 如果您想打开 `hello.txt` 文件后迅速执行一条命令，您可以向 `vim` 传递一个 `+{cmd}`/ `-c cmd` 选项。 在Vim中，您可以使用`:s` 命令（ `substitue` 的缩写）替换文本。如果您想打开 `hello.txt` 后立即将所有的"pancake"替换成"bagel"
      ```shell
      $ vim +%s/pancake/bagel/g hello.txt
      ```
  - 该命令可以被叠加
    collapsed:: true
    - 您可以使用 `o` 和 `O` 选项使Vim打开后分别显示为水平或垂直分割的窗口
    - 若想将Vim打开为2个水平分割的窗口，在终端中运行：`vim -o2`, `O` 同理
  - 挂起
    collapsed:: true
    - `Ctrl-z` / `:stop` / `:suspend`;
    - `fg`  -> 挂起返回
  - 您可以将`ls`命令的输出重定向到Vim中编辑，命令是`ls -l | vim -`
- ## Buffers & Windows & Tabs
  - 抽象 `buffers` / `windows` / `tabs`
    collapsed:: true
    - **buffer** 就是内存中的一块空间，您可以在这里写入或编辑文本。当您在Vim中打开一个文件时，文件的数据就与一个buffer绑定。当您在Vim中打开3个文件，您就有3个buffers
      collapsed:: true
      - 每当您打开一个新文件，Vim总是会创建一个新的buffer
      - `:buffers` / `:ls` / `:files`: 查看所有的buffers
      - 遍历所有buffers
      - `:bnext` 切换至下一个buffer（`:bprevious` 切换至前一个buffer）
      - `:buffer` + 文件名。（按下 `tab` 键Vim会自动补全文件名）
      - `:buffer` + `n`, n是buffer的编号
        collapsed:: true
        - 输入`:buffer 2` 将使您切换到buffer `#2`
      - 按下 `Ctrl-O` 将跳转至跳转列表中旧的位置，对应的，按下 `Ctrl-I` 将跳转至跳转列表中新的位置。这并不是属于buffer的特有方法，但它可以用来在不同的buffers中跳转
      - 按下 `Ctrl-^` 跳转至先前编辑过的buffer
      - 一旦Vim创建了一个buffer，它将保留在您的buffers列表中。若想删除它，您可以输入`:bdelete` 。这条命令也可以接收一个buffer编号（`:bdlete 3` 将删除buffer `#`3）或一个文件名（`:bdelete` 然后按 `` 自动补全文件名）
    - 退出Vim
      collapsed:: true
      - `:qall`
      - `:qall!`
      - `:wqall`
    - Windows
      collapsed:: true
      - `:split file2.js`
      - 窗口之间导航，使用这些快捷键：
      - `Ctrl-W H 移动光标到左边的窗口 `
      - `Ctrl-W J 移动光标到下面的窗口 `
      - `Ctrl-W K 移动光标到上面的窗口 `
      - `Ctrl-W L 移动光标到右边的窗口``
      - ``:vsplit file3.js ` 您现在看到的是三个窗口显示三个buffers
      - 另外，下面的列表列出了一些有用的关于windows的命令行命令
      - `:vsplit filename 垂直分割当前窗口，并在新窗口中打开名为filename的文件`
      - `:split filename 水平分割当前窗口，并在新窗口中打开名为filename的文件`
      - `:new filename 创建一个新窗口并打开名为filename的文件。`
    - Tabs
      collapsed:: true
      - `:tabnew file.txt 在tab中打开一个文件 `
        collapsed:: true
        - `:[count]tabe[dit]        *:tabe* *:tabedit* *:tabnew*`
          via: http://vimdoc.sourceforge.net/htmldoc/tabpage.html#:tab
        - `:tabnew`=`tabedit`
      - `:tabclose 关闭当前tab `
      - `:tabnext 切换至下一个tab `
      - `:tabprevious 切换至前一个tab `
      - `:tablast 切换至最后一个tab `
      - `:tabfirst 切换至第一个tab`
      - `:tabedit`
      - `gt` / `gT` : 切换到上下一个标签页
      - `3gt` 第3个tab
      - 好处: 在不同的tab中使用不同的窗口布局
      - 若想让Vim启动时就包含多个tabs，您可以在终端中运行命令 `vim -p file1.js file2.js file3.js`
  - 三维移动
    collapsed:: true
    - 在windows之间移动就像在笛卡尔坐标系的二维平面上沿着X-Y轴移动。您可以使用 `Ctrl-W H/J/K/L` 移动到上面、右侧、下面、以及左侧的窗口。
    - 在buffer之间移动就像在笛卡尔坐标系的Z轴上穿梭。想象您的buffer文件在Z轴上呈线性排列，您可以使用`:bnext` 和 `bprevious` 在Z轴上一次一个buffer地遍历。您也可以使用`:buffer 文件名/buffer编号` 在Z轴上跳转到任意坐标。
    - 结合window和buffer的移动，您可以在 __三维空间__ 中移动。您可以使用window导航命令移动到上面、右侧、下面、或左侧的窗口（X-Y平面导航）。因为每个window都可能包含了多个buffers，您可以使用buffer移动命令向前、向后移动（Z轴导航）
  - 我的工作流程：
    collapsed:: true
    - 首先，对于某个特定任务，我先使用buffers存储所有需要的文件。Vim就算打开很多buffer，速度一般也不会减慢。另外打开多个buffers并不会使我的屏幕变得拥挤。我始终只会看到1个buffer（假设我只有1个window），这可以让我注意力集中在1个屏幕上。当我需要使用其他文件时，可以快速切换至对应文件的buffer。
    - 当比对文件、读文档、或追踪代码流时，我使用多窗口来一次查看多个buffers。我尽量保持屏幕上的窗口数不超过3个，因为超过3个屏幕将变得拥挤（我使用的是小型笔记本）。当相应工作完成后，我就关掉多余的窗口。窗口越少可以使注意力更集中。
    - 我使用 [tmux](https://github.com/tmux/tmux/wiki) windows来代替tabs。通常一次使用多个tmux窗口。比如，一个tmux窗口用来写客户端代码，一个用来写后台代码。
  - `<C-w>`  在 `windows terminal` 会有问题, 快捷键改成`alt+w`
- ## Search
  - Open
    collapsed:: true
    - Vim中打开一个文件，您可以使用`:edit`
      - `:edit` 可以接收通配符参数。 `*` 匹配当前目录下的任意文件。如果您只想查找当前目录下后缀名为`.yml` 的文件：`:edit *.yml`
      - 使用 `**` 进行递归的搜索。如果您想查找当前项目文件夹下所有 `*.md` 文件，但您不知道在哪个目录，您可以这样做：`:edit **/*.md`
      - `:edit` 可以用于运行 `netrw` （Vim的内置文件浏览器）
  - Search
    collapsed:: true
    - `:find` 命令搜索文件
    - `:find` 命令根据 `path` 选项配置的路径查找文件，而`:edit` 不会
    - `path=.,/usr/include,,`
      - `.` 意思是在当前文件所在目录下搜索。(译者注：注意不是命令行输入pwd返回的当前目录，而是 **当前所打开的文件** 所在的目录)
      - `,` means to search in the current directory.(译者注：此处貌似作者有点小错误，逗号`,` 应该是表示路径之间的分割符。连续的两个`,,` （两个逗号之间为空）才表示当前目录)
      - `/usr/include` 表示在C编译器头文件目录下搜索。
  - `:set path+=$PWD/**`
    collapsed:: true
    - 虽然对于小项目没问题，但如果您的项目中包含大量文件时，这会显著降低您的搜索速度
      - windows下的Vim8.2，$PWD 这个环境变量在译者的vim中不起作用，必须在vimrc文件中添加一句 `let $PWD=getcwd()` 才行）
  - Grep
    collapsed:: true
    - 内置grep （`:vim` 。没错，就是`:vim` ，它是`:vimgrep` 的简写）
    - 外部grep (`:grep`)
- ## Grammar
  - 语法规则
    collapsed:: true
    - `verb + noun _ 动词 + 名词`
  - 名词(动作 Motion)
    collapsed:: true
    - `h 左`
    - `j 下`
    - `k 上`
    - `l 右`
    - `w 向前移动到下一个单词的开头`
    - `} 跳转到下一个段落`
    - `$ 跳转到当前行的末尾`
  - 动词(操作符 Operator)
    collapsed:: true
    - Vim共有16个 **操作符**
      collapsed:: true
      - `y yank(复制)`
      - `d delete(删除)`
      - `c change 删除文本，将删除的文本存到寄存器中，进入插入模式`
      - `p` 将它粘贴到光标后，或使用 `P` 粘贴到光标前
      - ... `:h operator`
  - 结合
    collapsed:: true
    - 复制当前位置到行尾的所有内容： `y$`
    - 删除当前位置到下一个单词的开头： `dw`
    - 修改当前位置到这个段落的结尾： `c}`
    - 向左拷贝2个字符： `y2h`
    - 删除后两个单词： `d2w`
    - 修改后面两行： `c2j`
  - 更多名词(文本对象 Text Objects)
    collapsed:: true
    - 文本对象可以被 **操作符 operations** 使用，这里有两类文本对象
    - `i + object 内部文本对象`
    - `a + object 外部文本对象`
      collapsed:: true
      - 删除括号内部的内容但保留括号：`di(`
      - 删除括号以及内部的内容：`da(`
    - 你可以在同一个位置指向不同的内容，可以删除一对小括号中的文本，也可以是当前大括号中的函数体，也可以是当前单词。这一点也很好记忆，当你看到 `di(`， `di{` 和 `diw` 时，你也可以很好的意识到他们表示的是什么：小括号，大括号，单词
    - 文本对象
      collapsed:: true
      - `w 一个单词`
      - `p 一个段落`
      - `s 一个句子`
      - `(或) 一对()`
      - `{或} 一对{}`
      - `[或] 一对[]`
      - `<或> 一对<>`
      - `t XML标签`
      - `" 一对""`
      - `' 一对''`
      - \`\` 一对\`\`
      - `:h text-objects`
- ## Moving in file
  - 字符导航
    collapsed:: true
    - __因为Bill Joy写VI用的Lear-Siegler ADM-3A终端没有方向键，而是把__ `hjkl` __当做方向键__
  - 相对行号
    collapsed:: true
    - `set relativenumber number`
  - 对移动计数
    collapsed:: true
    - `[计数] + 移动`
  - 单词导航
    collapsed:: true
    - `w 移动到下一个单词的开头`
    - `W 移动到下一个词组的开头`
    - `e 移动到下一个单词的结尾`
    - `E 移动到下一个词组的结尾`
    - `b 移动到前一个单词的开头`
    - `B 移动到前一个词组的开头`
    - `ge 移动到前一个单词的结尾`
    - `gE 移动到前一个词组的结尾`
    - 词组和单词到底有什么相同和不同呢？单词和词组都按照非空字符被分割，一个单词指的是一个只包含 `a-zA-Z0-9` 字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串。 你可以通过`:h word` 和`:h WORD` 了解更多
  - 当前行导航
    collapsed:: true
    - `0 跳到本行第一个字符`
    - `^ 跳到本行第一个非空字符`
    - `g_ 跳到本行最后一个非空字符`
    - `$ 跳到本行最后一个字符 `
    - `n| 跳到本行第n列`
    - 你也可以在本行通过 `f` 和 `t` 进行行内搜索， `f` 和 `t` 的区别在于 `f` 会停在第一个匹配的字母上， `t` 会停在第一个匹配的字母前。 因此如果你想要搜索并停留在"h"上，使用 `fh` 。 如果你想搜索第一个"h"并停留在它的前一个字母上，可以使用 `th` 。 如果你想去下一个行内匹配的位置，使用`;` ，如果你想去前一个行内匹配的位置，使用`,`
    - `f 在同一行向后搜索第一个匹配`
    - `F 在同一行向前搜索第一个匹配`
    - `t 在同一行向后搜索第一个匹配，并停在匹配前`
    - `T 在同一行向前搜索第一个匹配，并停在匹配前`
    - `; 在同一行重复最近一次搜索`
    - `, 在同一行向相反方向重复最近一次搜索`
  - 句子和段落导航
    collapsed:: true
    - 一个句子的定义是以`.!?` 和跟着的一个换行符或空格，tab结尾的
    - `( 跳到前一个句子`
    - `) 跳到下一个句子`
    - 另外，如果你的Vim中遇到了无法将一个以`.` 结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题，你可能处于 `compatible` 的模式。 运行`:set nocompatible` 可以修复。 在Vi中，一个句子是以 **两个** 空格结尾的，你应该总是保持的 `nocompatible` 的设置
    - 一个段落可以从一个空行之后开始，也可以从段落选项(`paragraphs`)中"字符对"所指定的段落宏的每个集合开始
    - `{ 跳转到上一个段落`
    - `} 跳转到下一个段落`
    - 通过`:h setence` 和`:h paragraph` 了解更多
  - 匹配导航
    collapsed:: true
    - 通过`:h %` 了解更多
  - 行号导航
    collapsed:: true
    - `nG` 调到行号为 `n` 的行
    - `gg 跳转到第一行`
    - `G 跳转到最后一行`
    - `nG 跳转到第n行`
    - `n% 跳到文件的n%`
    - 文件总行数，可以用 `CTRL-g` 查看
  - 窗格导航
    collapsed:: true
    - `H 跳转到屏幕的顶部`
    - `M 跳转到屏幕的中间`
    - `L 跳转到屏幕的底部`
    - `nH 跳转到距离顶部n行的位置`
    - `nL 跳转到距离底部n行的位置`
  - 滚动
    collapsed:: true
    - 滚动一整页(`CTRL-F` / `CTRL-B`)
    - 滚动半页(`CTRL-D` / `CTRL-U`)
    - 滚动一行 `CTRL-E` / `CTRL-Y`)
    - `zt 将当前行置于屏幕顶部附近`
    - `zz 将当前行置于屏幕中央`
    - `zb 将当前行置于屏幕底部`
  - 搜索导航
    collapsed:: true
    - `/` 向下搜索，也可以通过`?` 向上搜索一个字段
    - 通过 `n` 重复最近一次搜索， `N` 向反方向重复最近一次搜索
    - `/ 向后搜索一个匹配`
    - `? 向前搜素一个匹配`
    - `n 重复上一次搜索(和上一次方向相同)`
    - `N 重复上一次搜索(和上一次方向相反)`
    - 你可以通过`:set hlsearch` 设置搜索高亮。 这样，当你搜索 `/let` ，它将高亮文件中所有匹配的字段。 另外，如果你通过`:set incsearch` 设置了增量搜索，它将在你输入时不断匹配的输入的内容。 默认情况下，匹配的字段会一直高亮到你搜索另一个字段，这有时候很烦人，如果你希望取消高亮，可以使用`:nohlsearch` 。 因为我经常使用这个功能，所以我会设置一个映射
    - `nnoremap <esc><esc> :noh<return><esc>`
    - `* 向后查找光标所在的完整单词`
    - `_ 向前查找光标所在的完整单词`
    - `g* 向后搜索光标所在的单词`
    - `g_ 向前搜索光标所在的单词`
  - 位置标记
    collapsed:: true
    - `ma 用a标签标记一个位置`
    - ``a 精确回到a标签的位置(行和列)`
    - `'a 跳转到a标签的行`
    - `a-z` 的标签和 `A-Z` 的标签存在一个区别，小写字母是局部标签，大写字母是全局标签(也称文件标记)
    - `:marks` 查看所有标签
    - `'' 在当前buffer中跳转回到上一次跳转前的最后一行`
    - ``` 在当前buffer中跳转回到上一次跳转前的最后一个位置`
            - ``[ 跳转到上一次修改或拷贝的文本的开头`
            - ``] 跳转到上一次修改或拷贝的文本的结尾`
            - ``< 跳转到最近一次可视模式下选择的部分的开头`
            - ``> 跳转到最近一次可视模式下选择的部分的结尾`
            - ``0 跳转到退出Vim前编辑的最后一个文件`
            - `: marks`
          - 跳转
            collapsed:: true
            - `h jump-motions`
        - Insert mode
          - 所敲即所得
          - 方法
            collapsed:: true
            - `i 从光标之前的位置开始输入文本`
            - `I 从当前行第一个非空字符之前的位置之前开始输入文本`
            - `a 在光标之后的位置追加文本`
            - `A 在当前行的末尾追加文本`
            - `o 在光标位置下方新起一行并开始输入文本`
            - `O 在光标位置的上方新起一行并开始输入文本`
            - `s 删除当前光标位置的字符并开始输入文本 `
            - `S 删除当前行并开始输入文本 `
            - `gi 从当前缓冲区上次结束输入模式的地方开始输入文本 `
            - `gI 在当前行的第一列的位置开始输入文本 `
          - 退出输入模式
            collapsed:: true
            - `<esc> 退出输入模式进入普通模式`
            - `Ctrl-[ 退出输入模式进入普通模式`
            - `Ctrl-c 与 Ctrl-[ 和 <esc>功能相同, 但是不检查缩写`
          - 重复输入模式
            collapsed:: true
            - `10i`
      - 输入“hello world!”然后退出输入模式， Vim将重复这段文本10次
      - 不可以有换行, 好像是因为换行刷新缓冲区
          - 输入模式中删除大块文本
            collapsed:: true
            - `Ctrl-h 删除一个字符`
            - `Ctrl-w 删除一个单词`
            - `Ctrl-u 删除一整行`
          - 寄存器进行输入
            collapsed:: true
            - 输入模式下，可以使用快捷键 `Ctrl-r` 加上寄存器的标识来从任何有标识的寄存器输入文本
            - 以（a-z)命名的寄存器
          - 页面滚动
            collapsed:: true
            - `Ctrl-x Ctrl-y 向上滚动页面`
            - `Ctrl-x Ctrl-e 向下滚动页面`
          - 自动补全
            collapsed:: true
            - 子模式后（和页面滚动一样），有一个自带的自动补全功能。尽管它不如intellisense或者其他的语言服务器协议（LSP）一样好用，但是也算是一个锦上添花的内置功能了
            - `Ctrl-x Ctrl-l 补全一整行`
            - `Ctrl-x Ctrl-n 从当前文件中补全文本`
            - `Ctrl-x Ctrl-i 从引用（include）的文件中补全文本`
            - `Ctrl-x Ctrl-f 补全一个文件名`
            - `Ctrl-n` 和 `Ctrl-p` 来分别向上和向下浏览选项
            - `Ctrl-n 使用下一个匹配的单词进行补全`
            - `Ctrl-p 使用上一个匹配的单词进行补全`
            - `:h ins-completion`
          - 执行普通模式下的命令
            collapsed:: true
            - `Ctrl-o` ，你就会进入到 `insert-normal` （输入-普通）子模式
            - `-- (insert) --`
            - **设置居中以及跳转**
      - `Ctrl-o zz 居中窗口`
      - `Ctrl-o H/M/L 跳转到窗口的顶部/中部/底部`
      - `Ctrl-o 'a 跳转到标志'a处`
            - **重复文本**
      - `Ctrl-o 100ihello 输入 "hello" 100 次`
            - **执行终端命令**
      - `Ctrl-o !! curl https://google.com 运行curl命令`
      - `Ctrl-o !! pwd 运行pwd命令`
            - **快速删除**
      - `Ctrl-o dtz 从当前位置开始删除文本，直到遇到字母"z"`
      - `Ctrl-o D 从当前位置开始删除文本，直到行末`
      - 强烈反对你在没有输入文本时，却仍然待在输入模式下。应该养成当你的双手没有在输入时，就退出到普通模式的好习惯
      - 尽量避免重复输入同一个单词
        - Dot command
          - 点命令是最简单的命令，然而又是减少重复操作最为有用的命令
          - `.` 键来使用点命令
          - 当你使用普通模式下的命令来更新（添加，修改或者删除）当前缓冲区中的内容时，你就是在执行一个修改操作了。其中的例外是使用命令行命令进行的修改（以 `：` 开头的命令），这些命令不算作修改操作
          - `gn` 是一个移动并选择的动作，它向前搜索和上一个搜索的模式（本例中为 `/let` ）匹配的位置，并且 **自动对匹配的文本进行可视化模式下的选取**
        - Registers
          - 除非你学习了他们，否则你会觉得自己根本不需要它们
          - 10种类型
            collapsed:: true
            - 匿名寄存器（`""`）.
            - 编号寄存器(`"0-9`)
            - 小删除寄存器 (`"-`).
            - 命名寄存器 (`"a-z`).
            - 只读寄存器 (`":`, `".`, and `"%`).
            - Buffer交替文件寄存器 (`"_`).
            - 表达式寄存器 (`"=`).
            - 选取和拖放寄存器(`"*` and `"+`).
            - 黑洞寄存器 (`"_`).
            - 搜索模式寄存器 (`"/`).
          - 寄存器命令
            collapsed:: true
            - `y 复制`
            - `c 删除文本并进入输入模式`
            - `d 删除文本`
            - `p 在光标位置之后粘贴文本`
            - `P 在光标位置之前粘贴文本`
            - 命令 `p` 实际上表示的是"put"(放置)，而不是"paste"(粘贴)，使用粘贴只是因为它更符合传统习惯
            - 从某个特定寄存器中读取文本的通用语法是`"x` ，其中 `x` 是这个寄存器的标志
          - 输入模式中使用寄存器
            collapsed:: true
            - 输入模式下时，你需要运行 `Ctrl-r a`
            - `Ctrl-r x, `其中 `x` 是寄存器标志
          - 匿名寄存器(`""`)
            collapsed:: true
            - `""p`: 默认存储着你最近一次复制，修改或删除的文本
          - 编号寄存器(`"0-9`)
            collapsed:: true
            - 自动以升序来进行填充
            - 复制寄存器(`0`)和其他编号寄存器(`1-9`)
            - 如果你使用 `yy` 来复制一整行文本，事实上Vim会将文本存放两个寄存器中
      - 匿名寄存器 (`p`).
      - 复制寄存器 (`"0p`).
            - Vim会自动替换匿名寄存器和复制寄存器(`0`)中的内容。其他的任何操作都不会被存放在 `0` 号寄存器中。这可以为你提供方便，因为除非你再进行另一次复制，否则你已经复制的内容会一直在寄存器中，无论你进行多少次修改和删除
            - 输入模式下，你可以使用 `Ctrl-r 0` 快速地粘贴你刚才复制的内容
            - 当你修改或者删除至少一整行的文本时，这部分文本会按时间顺序被存储在1-9号编号寄存器中
            - 编号越小时间距离越近
      - 使用`"1p` 来粘贴1号寄存器中的内容
      - 使用`.` (点命令)来粘贴2号寄存器（`"2` ）中的内容
      - 使用`.` (点命令)来粘贴3号寄存器（`"3` ）中的内容
            - 在连续地使用点命令时，Vim会自动的增加编号寄存器的编号。这个技巧对于所有的编号寄存器都适用
            - 小型的删除比如单词删除（ `dw`)或者单词修改(`cw`)不会被存储在编号寄存器中，它们被存储在小删除寄存器(`"-`)中
          - 小删除寄存器(`"-`)
            collapsed:: true
            - 不足一行的修改或者删除都不会被存储在0-9号编号寄存器中，而是会被存储在小删除寄存器 (`"-`)中
            - 只能存储一个文本
          - 命名寄存器 (`"a-z`)
            collapsed:: true
            - a-z命名寄存器可以存储复制的，修改的和被删除的文本
            - 为了复制一个单词到寄存器"a"中，你可以使用命令`"ayiw`
      - `"a` 告诉Vim下一个动作（删除/修改/复制）会被存储在寄存器"a"中
      - `yiw` 复制这个单词
            - 为了从寄存器"a"中获取文本，可以使用命令`"ap`
            - 你可以使用大写版本的命名寄存器来进行文本的追加
          - 只读寄存器(`":`, `".`, `"%`)
            collapsed:: true
            - `. 存储上一个输入的文本`
            - `: 存储上一次执行的命令`
            - `% 存储当前文件的文件名`
          - Buffer交替文件寄存器 (`"_`)
            collapsed:: true
            - `_` 通常代表交替文件。交替文件指的是你上一个打开的文件，想要插入交替文件的名字的话，可以使用命令`"_p`
          - 表达式寄存器 (`"=`)
            collapsed:: true
            - 表达式是Vim中非常宏大的一个话题
          - 选取和拖放寄存器 (`"*`, `"+`)
            collapsed:: true
            - Vim有两个选取寄存器： `quotestar` (`"*`) 和 `quoteplus` (`"+`)。你可以用它们来访问从外部程序中复制的文本
            - ==使用`"+p` 和`"*p` 来粘贴这些文本==。
            - ==使用`"+yiw` 或者`"*yiw` 在Vim中复制了一些文本，你可以使用 `Ctrl-v` （或者 `Cmd-v` ）==
      - 值得注意的是这个方法只在你的Vim开启了`+clipboard` 选项时才有用，可以在命令行中运行 `vim --version` 查看这一选项。如果你看见`-clipboard` 的话，则需要安装一下支持Vim粘贴板的配置
          - 黑洞寄存器 (`"_`)
            collapsed:: true
            - 。想要删除一行并且不将其存储在任何寄存器中时，可以使用`"_dd` 命令.
          - 搜索模式寄存器 (`"/`)
            collapsed:: true
            - 粘贴你的上一个搜索询问
            - 使用命令 `"/p` 就能粘贴上一个搜索的条目
            - `:register` 命令来查看你的所有寄存器
            - 只想查看"a","1"和"-"寄存器的内容的话则可以使用命令`:register a 1 -`
            - 有一个Vim的插件叫做 [vim-peekaboo](https://github.com/junegunn/vim-peekaboo) ,可以让你查看到寄存器的内容，在普通模式下输入`"`或 `@` 即可，或者在输入模式中输入 `Ctrl-r` 。我发现这个插件相当的有用，因为大多数时候我是记不住我的寄存器中的内容的。值得一试！
          - 执行寄存器
            collapsed:: true
            - 借助 `@` 来执行宏命令
          - 清除寄存器
            collapsed:: true
            - 记录一个空的宏命令来快速地清除任何命名寄存器
            - 如果你运行 `qaq` ，Vim就会在寄存器"a"中记录一个空的宏命令
            - 还有一种方法就是运行命令`:call setreg('a','hello register a')`,其中'a'代表的就是寄存器"a"。而"hello register a"就是你想存储的内容
            - 还有一种清除寄存器的方法就是使用表达式`:let @a = ''` 来将寄存器"a 的值设为空的字符串
          - 获取寄存器中的内容
            collapsed:: true
            - `:put` 命令来粘贴任何寄存器的内容
            - 唯一的区别在于在普通模式下命令 `p` 在当前光标位置之后打印寄存器的内容，而`:put` 新起一行来打印寄存器的内容
            - 一个很酷的技巧是将黑洞寄存器(`"_`)传给`:put` 命令。因为黑洞寄存器不保存任何值，`:put _` 命令将插入一个新的空白行。您可将这个与全局命令联合起来，插入多个空行。比如，要在所有以文本"end"结尾的行下插入空行，使用`:g/end/put _`
        - WAITING macros
          - 通过 Vim 的宏命令，你可以将一些动作记录到 Vim 寄存器
          - 宏命令的基本语法如下：
          - `qa 开始记录动作到寄存器 a`
          - `q (while recording) 停止记录`
      -
      - Cases
        - **当前行新起一空行且进入插入模式**: o
        - **全选** `ggvG`/`ggVG`: 其中 `gg`是让光标移到首行 **[vim特有]**,
          collapsed:: true
          - `v/V`切换到可视化(Visual),
          - `G`则移到最后一行`:$`
        - [移动(缩进)代码](https://segmentfault.com/q/1010000000343626)
          collapsed:: true
          - 先进visual模式，然后选中要移动的代码快，按shift+<就可以整体移动了。
          - ```shell
            10,100> #第10行至第100行缩进
            20,80< #第20行至第80行反缩进
            ```
  - 提供另一个方法，不用进 V 模式
    collapsed:: true
    - 移动到需要处理的首行，ma
    - 移动到需要处理的末行，<'a